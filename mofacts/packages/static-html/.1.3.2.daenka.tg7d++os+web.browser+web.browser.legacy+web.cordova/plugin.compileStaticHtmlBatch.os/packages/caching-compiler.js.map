{"version":3,"sources":["meteor://ðŸ’»app/packages/caching-compiler/caching-compiler.js","meteor://ðŸ’»app/packages/caching-compiler/multi-file-caching-compiler.js"],"names":["fs","Plugin","path","createHash","Npm","require","assert","LRU","CachingCompilerBase","constructor","compilerName","defaultCacheSize","maxParallelism","_compilerName","_maxParallelism","compilerNameForEnvar","toUpperCase","replace","envVarPrefix","debugEnvVar","_cacheDebugEnabled","process","env","cacheSizeEnvVar","_cacheSize","_diskCache","_callCount","_afterLinkCallbacks","getCacheKey","inputFile","Error","addCompileResult","compileResult","compileResultSize","stringifyCompileResult","JSON","stringify","parseCompileResult","stringifiedCompileResult","_parseJSONOrNull","json","parse","e","SyntaxError","_cacheDebug","message","console","log","setDiskCacheDirectory","diskCache","sourceMapSize","sm","mappings","length","sourcesContent","reduce","soFar","current","afterLink","splice","forEach","callback","_deepHash","val","hash","type","update","keys","Object","Array","isArray","sort","key","ok","digest","_writeFile","filename","contents","tempFilename","Random","id","writeFileSync","renameSync","_readFileOrNull","readFileSync","code","CachingCompiler","_cache","max","value","compileOneFile","processFilesForTarget","inputFiles","cacheMisses","arches","create","getArch","getResult","cacheKey","get","_readCache","getDisplayPath","push","Promise","await","set","_writeCacheAsync","compileOneFileLater","supportsLazyCompilation","result","_cacheFilename","test","join","cacheFilename","_readAndParseCompileResultOrNull","cacheContents","raw","MultiFileCachingCompiler","allFiles","isRoot","getAbsoluteImportPath","getPackageName","getPathInPackage","Map","cacheKeyMap","importPath","_getCacheKeyWithPath","absoluteImportPath","cacheEntry","_cacheEntryValid","compileOneFileReturn","referencedImportPaths","cacheKeys","has","getFileOptions","lazy","every","newlineIndex","indexOf","cacheKeysString","substring","compileResultString"],"mappings":"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","file":"/packages/caching-compiler.js","sourcesContent":["const fs = Plugin.fs;\nconst path = Plugin.path;\nconst createHash = Npm.require('crypto').createHash;\nconst assert = Npm.require('assert');\nconst LRU = Npm.require('lru-cache');\n\n// Base class for CachingCompiler and MultiFileCachingCompiler.\nCachingCompilerBase = class CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    this._compilerName = compilerName;\n    this._maxParallelism = maxParallelism;\n    const compilerNameForEnvar = compilerName.toUpperCase()\n      .replace('/-/g', '_').replace(/[^A-Z0-9_]/g, '');\n    const envVarPrefix = 'METEOR_' + compilerNameForEnvar + '_CACHE_';\n\n    const debugEnvVar = envVarPrefix + 'DEBUG';\n    this._cacheDebugEnabled = !! process.env[debugEnvVar];\n\n    const cacheSizeEnvVar = envVarPrefix + 'SIZE';\n    this._cacheSize = +process.env[cacheSizeEnvVar] || defaultCacheSize;\n\n    this._diskCache = null;\n\n    // For testing.\n    this._callCount = 0;\n\n    // Callbacks that will be called after the linker is done processing\n    // files, after all lazy compilation has finished.\n    this._afterLinkCallbacks = [];\n  }\n\n  // Your subclass must override this method to define the key used to identify\n  // a particular version of an InputFile.\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), returns a cache key that represents\n  // it. This cache key can be any JSON value (it will be converted internally\n  // into a hash).  This should reflect any aspect of the InputFile that affects\n  // the output of `compileOneFile`. Typically you'll want to include\n  // `inputFile.getDeclaredExports()`, and perhaps\n  // `inputFile.getPathInPackage()` or `inputFile.getDeclaredExports` if\n  // `compileOneFile` pays attention to them.\n  //\n  // Note that for MultiFileCachingCompiler, your cache key doesn't need to\n  // include the file's path, because that is automatically taken into account\n  // by the implementation. CachingCompiler subclasses can choose whether or not\n  // to include the file's path in the cache key.\n  getCacheKey(inputFile) {\n    throw Error('CachingCompiler subclass should implement getCacheKey!');\n  }\n\n  // Your subclass must override this method to define how a CompileResult\n  // translates into adding assets to the bundle.\n  //\n  // This method is given an InputFile (the data type passed to\n  // processFilesForTarget as part of the Plugin.registerCompiler API) and a\n  // CompileResult (either returned directly from compileOneFile or read from\n  // the cache).  It should call methods like `inputFile.addJavaScript`\n  // and `inputFile.error`.\n  addCompileResult(inputFile, compileResult) {\n    throw Error('CachingCompiler subclass should implement addCompileResult!');\n  }\n\n  // Your subclass must override this method to define the size of a\n  // CompilerResult (used by the in-memory cache to limit the total amount of\n  // data cached).\n  compileResultSize(compileResult) {\n    throw Error('CachingCompiler subclass should implement compileResultSize!');\n  }\n\n  // Your subclass may override this method to define an alternate way of\n  // stringifying CompilerResults.  Takes a CompileResult and returns a string.\n  stringifyCompileResult(compileResult) {\n    return JSON.stringify(compileResult);\n  }\n  // Your subclass may override this method to define an alternate way of\n  // parsing CompilerResults from string.  Takes a string and returns a\n  // CompileResult.  If the string doesn't represent a valid CompileResult, you\n  // may want to return null instead of throwing, which will make\n  // CachingCompiler ignore the cache.\n  parseCompileResult(stringifiedCompileResult) {\n    return this._parseJSONOrNull(stringifiedCompileResult);\n  }\n  _parseJSONOrNull(json) {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      if (e instanceof SyntaxError)\n        return null;\n      throw e;\n    }\n  }\n\n  _cacheDebug(message) {\n    if (!this._cacheDebugEnabled)\n      return;\n    console.log(`CACHE(${ this._compilerName }): ${ message }`);\n  }\n\n  setDiskCacheDirectory(diskCache) {\n    if (this._diskCache)\n      throw Error('setDiskCacheDirectory called twice?');\n    this._diskCache = diskCache;\n  }\n\n  // Since so many compilers will need to calculate the size of a SourceMap in\n  // their compileResultSize, this method is provided.\n  sourceMapSize(sm) {\n    if (! sm) return 0;\n    // sum the length of sources and the mappings, the size of\n    // metadata is ignored, but it is not a big deal\n    return sm.mappings.length\n      + (sm.sourcesContent || []).reduce(function (soFar, current) {\n        return soFar + (current ? current.length : 0);\n      }, 0);\n  }\n\n  // Called by the compiler plugins system after all linking and lazy\n  // compilation has finished.\n  afterLink() {\n    this._afterLinkCallbacks.splice(0).forEach(callback => {\n      callback();\n    });\n  }\n\n  // Borrowed from another MIT-licensed project that benjamn wrote:\n  // https://github.com/reactjs/commoner/blob/235d54a12c/lib/util.js#L136-L168\n  _deepHash(val) {\n    const hash = createHash('sha1');\n    let type = typeof val;\n\n    if (val === null) {\n      type = 'null';\n    }\n    hash.update(type + '\\0');\n\n    switch (type) {\n    case 'object':\n      const keys = Object.keys(val);\n\n      // Array keys will already be sorted.\n      if (! Array.isArray(val)) {\n        keys.sort();\n      }\n\n      keys.forEach((key) => {\n        if (typeof val[key] === 'function') {\n          // Silently ignore nested methods, but nevertheless complain below\n          // if the root value is a function.\n          return;\n        }\n\n        hash.update(key + '\\0').update(this._deepHash(val[key]));\n      });\n\n      break;\n\n    case 'function':\n      assert.ok(false, 'cannot hash function objects');\n      break;\n\n    default:\n      hash.update('' + val);\n      break;\n    }\n\n    return hash.digest('hex');\n  }\n\n  // Write the file atomically.\n  _writeFile(filename, contents) {\n    const tempFilename = filename + '.tmp.' + Random.id();\n\n    try {\n      fs.writeFileSync(tempFilename, contents);\n      fs.renameSync(tempFilename, filename);\n    } catch (e) {\n      // ignore errors, it's just a cache\n      this._cacheDebug(e);\n    }\n  }\n\n  // Helper function. Returns the body of the file as a string, or null if it\n  // doesn't exist.\n  _readFileOrNull(filename) {\n    try {\n      return fs.readFileSync(filename, 'utf8');\n    } catch (e) {\n      if (e && e.code === 'ENOENT')\n        return null;\n      throw e;\n    }\n  }\n}\n\n// CachingCompiler is a class designed to be used with Plugin.registerCompiler\n// which implements in-memory and on-disk caches for the files that it\n// processes.  You should subclass CachingCompiler and define the following\n// methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.\n//\n// CachingCompiler assumes that files are processed independently of each other;\n// there is no 'import' directive allowing one file to reference another.  That\n// is, editing one file should only require that file to be rebuilt, not other\n// files.\n//\n// The data that is cached for each file is of a type that is (implicitly)\n// defined by your subclass. CachingCompiler refers to this type as\n// `CompileResult`, but this isn't a single type: it's up to your subclass to\n// decide what type of data this is.  You should document what your subclass's\n// CompileResult type is.\n//\n// Your subclass's compiler should call the superclass compiler specifying the\n// compiler name (used to generate environment variables for debugging and\n// tweaking in-memory cache size) and the default cache size.\n//\n// By default, CachingCompiler processes each file in \"parallel\". That is, if it\n// needs to yield to read from the disk cache, or if getCacheKey,\n// compileOneFile, or addCompileResult yields, it will start processing the next\n// few files. To set how many files can be processed in parallel (including\n// setting it to 1 if your subclass doesn't support any parallelism), pass the\n// maxParallelism option to the superclass constructor.\n//\n// For example (using ES2015 via the ecmascript package):\n//\n//   class AwesomeCompiler extends CachingCompiler {\n//     constructor() {\n//       super({\n//         compilerName: 'awesome',\n//         defaultCacheSize: 1024*1024*10,\n//       });\n//     }\n//     // ... define the other methods\n//   }\n//   Plugin.registerCompile({\n//     extensions: ['awesome'],\n//   }, () => new AwesomeCompiler());\n//\n// XXX maybe compileResultSize and stringifyCompileResult should just be methods\n// on CompileResult? Sort of hard to do that with parseCompileResult.\nCachingCompiler = class CachingCompiler extends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from a hashed cache key to a compileResult.\n    this._cache = new LRU({\n      max: this._cacheSize,\n      length: (value) => this.compileResultSize(value),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), compiles the file and returns a\n  // CompileResult (the cacheable data type specific to your subclass).\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile) {\n    throw Error('CachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API. If\n  // you have processing you want to perform at the beginning or end of a\n  // processing phase, you may want to override this method and call the\n  // superclass implementation from within your method.\n  async processFilesForTarget(inputFiles) {\n    const cacheMisses = [];\n    const arches = this._cacheDebugEnabled && Object.create(null);\n\n    inputFiles.forEach(inputFile => {\n      if (arches) {\n        arches[inputFile.getArch()] = 1;\n      }\n\n      const getResult = () => {\n        const cacheKey = this._deepHash(this.getCacheKey(inputFile));\n        let compileResult = this._cache.get(cacheKey);\n\n        if (! compileResult) {\n          compileResult = this._readCache(cacheKey);\n          if (compileResult) {\n            this._cacheDebug(`Loaded ${ inputFile.getDisplayPath() }`);\n          }\n        }\n\n        if (! compileResult) {\n          cacheMisses.push(inputFile.getDisplayPath());\n          compileResult = Promise.await(this.compileOneFile(inputFile));\n\n          if (! compileResult) {\n            // compileOneFile should have called inputFile.error.\n            //  We don't cache failures for now.\n            return;\n          }\n\n          // Save what we've compiled.\n          this._cache.set(cacheKey, compileResult);\n          this._writeCacheAsync(cacheKey, compileResult);\n        }\n\n        return compileResult;\n      };\n\n      if (this.compileOneFileLater &&\n          inputFile.supportsLazyCompilation) {\n        this.compileOneFileLater(inputFile, getResult);\n      } else {\n        const result = getResult();\n        if (result) {\n          this.addCompileResult(inputFile, result);\n        }\n      }\n    });\n\n    if (this._cacheDebugEnabled) {\n      this._afterLinkCallbacks.push(() => {\n        cacheMisses.sort();\n\n        this._cacheDebug(\n          `Ran (#${\n            ++this._callCount\n          }) on: ${\n            JSON.stringify(cacheMisses)\n          } ${\n            JSON.stringify(Object.keys(arches).sort())\n          }`\n        );\n      });\n    }\n  }\n\n  _cacheFilename(cacheKey) {\n    // We want cacheKeys to be hex so that they work on any FS and never end in\n    // .cache.\n    if (!/^[a-f0-9]+$/.test(cacheKey)) {\n      throw Error('bad cacheKey: ' + cacheKey);\n    }\n    return path.join(this._diskCache, cacheKey + '.cache');\n  }\n  // Load a cache entry from disk. Returns the compileResult object\n  // and loads it into the in-memory cache too.\n  _readCache(cacheKey) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const compileResult = this._readAndParseCompileResultOrNull(cacheFilename);\n    if (! compileResult) {\n      return null;\n    }\n    this._cache.set(cacheKey, compileResult);\n    return compileResult;\n  }\n  _writeCacheAsync(cacheKey, compileResult) {\n    if (! this._diskCache)\n      return;\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const cacheContents = this.stringifyCompileResult(compileResult);\n    this._writeFile(cacheFilename, cacheContents);\n  }\n\n  // Returns null if the file does not exist or can't be parsed; otherwise\n  // returns the parsed compileResult in the file.\n  _readAndParseCompileResultOrNull(filename) {\n    const raw = this._readFileOrNull(filename);\n    return this.parseCompileResult(raw);\n  }\n}\n","const path = Plugin.path;\nconst LRU = Npm.require('lru-cache');\n\n// MultiFileCachingCompiler is like CachingCompiler, but for implementing\n// languages which allow files to reference each other, such as CSS\n// preprocessors with `@import` directives.\n//\n// Like CachingCompiler, you should subclass MultiFileCachingCompiler and define\n// the following methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.  compileOneFile gets an additional allFiles argument and\n// returns an array of referenced import paths in addition to the CompileResult.\n// You may also override isRoot and getAbsoluteImportPath to customize\n// MultiFileCachingCompiler further.\nMultiFileCachingCompiler = class MultiFileCachingCompiler\nextends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from cache key to { compileResult, cacheKeys }, where\n    // cacheKeys is an object mapping from absolute import path to hashed\n    // cacheKey for each file referenced by this file (including itself).\n    this._cache = new LRU({\n      max: this._cacheSize,\n      // We ignore the size of cacheKeys here.\n      length: (value) => this.compileResultSize(value.compileResult),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Arguments:\n  //   - inputFile is the InputFile to process\n  //   - allFiles is a a Map mapping from absolute import path to InputFile of\n  //     all files being processed in the target\n  // Returns an object with keys:\n  //   - compileResult: the CompileResult (the cacheable data type specific to\n  //     your subclass).\n  //   - referencedImportPaths: an array of absolute import paths of files\n  //     which were refererenced by the current file.  The current file\n  //     is included implicitly.\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile, allFiles) {\n    throw Error(\n      'MultiFileCachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // Your subclass may override this to declare that a file is not a \"root\" ---\n  // ie, it can be included from other files but is not processed on its own. In\n  // this case, MultiFileCachingCompiler won't waste time trying to look for a\n  // cache for its compilation on disk.\n  isRoot(inputFile) {\n    return true;\n  }\n\n  // Returns the absolute import path for an InputFile. By default, this is a\n  // path is a path of the form \"{package}/path/to/file\" for files in packages\n  // and \"{}/path/to/file\" for files in apps. Your subclass may override and/or\n  // call this method.\n  getAbsoluteImportPath(inputFile) {\n    if (inputFile.getPackageName() === null) {\n      return '{}/' + inputFile.getPathInPackage();\n    }\n    return '{' + inputFile.getPackageName() + '}/'\n      + inputFile.getPathInPackage();\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API.\n  async processFilesForTarget(inputFiles) {\n    const allFiles = new Map;\n    const cacheKeyMap = new Map;\n    const cacheMisses = [];\n    const arches = this._cacheDebugEnabled && Object.create(null);\n\n    inputFiles.forEach((inputFile) => {\n      const importPath = this.getAbsoluteImportPath(inputFile);\n      allFiles.set(importPath, inputFile);\n      cacheKeyMap.set(importPath, this._getCacheKeyWithPath(inputFile));\n    });\n\n    inputFiles.forEach(inputFile => {\n      if (arches) {\n        arches[inputFile.getArch()] = 1;\n      }\n\n      const getResult = () => {\n        const absoluteImportPath = this.getAbsoluteImportPath(inputFile);\n        const cacheKey = cacheKeyMap.get(absoluteImportPath);\n        let cacheEntry = this._cache.get(cacheKey);\n        if (! cacheEntry) {\n          cacheEntry = this._readCache(cacheKey);\n          if (cacheEntry) {\n            this._cacheDebug(`Loaded ${ absoluteImportPath }`);\n          }\n        }\n\n        if (! (cacheEntry && this._cacheEntryValid(cacheEntry, cacheKeyMap))) {\n          cacheMisses.push(inputFile.getDisplayPath());\n\n          const compileOneFileReturn =\n            Promise.await(this.compileOneFile(inputFile, allFiles));\n\n          if (! compileOneFileReturn) {\n            // compileOneFile should have called inputFile.error.\n            // We don't cache failures for now.\n            return;\n          }\n\n          const {\n            compileResult,\n            referencedImportPaths,\n          } = compileOneFileReturn;\n\n          cacheEntry = {\n            compileResult,\n            cacheKeys: {\n              // Include the hashed cache key of the file itself...\n              [absoluteImportPath]: cacheKeyMap.get(absoluteImportPath)\n            }\n          };\n\n          // ... and of the other referenced files.\n          referencedImportPaths.forEach((path) => {\n            if (!cacheKeyMap.has(path)) {\n              throw Error(`Unknown absolute import path ${ path }`);\n            }\n            cacheEntry.cacheKeys[path] = cacheKeyMap.get(path);\n          });\n\n          // Save the cache entry.\n          this._cache.set(cacheKey, cacheEntry);\n          this._writeCacheAsync(cacheKey, cacheEntry);\n        }\n\n        return cacheEntry.compileResult;\n      };\n\n      if (this.compileOneFileLater &&\n          inputFile.supportsLazyCompilation) {\n        if (! this.isRoot(inputFile)) {\n          // If this inputFile is definitely not a root, then it must be\n          // lazy, and this is our last chance to mark it as such, so that\n          // the rest of the compiler plugin system can avoid worrying\n          // about the MultiFileCachingCompiler-specific concept of a\n          // \"root.\" If this.isRoot(inputFile) returns true instead, that\n          // classification may not be trustworthy, since returning true\n          // used to be the only way to get the file to be compiled, so\n          // that it could be imported later by a JS module. Now that\n          // files can be compiled on-demand, it's safe to pass all files\n          // that might be roots to this.compileOneFileLater.\n          inputFile.getFileOptions().lazy = true;\n        }\n        this.compileOneFileLater(inputFile, getResult);\n      } else if (this.isRoot(inputFile)) {\n        const result = getResult();\n        if (result) {\n          this.addCompileResult(inputFile, result);\n        }\n      }\n    });\n\n    if (this._cacheDebugEnabled) {\n      this._afterLinkCallbacks.push(() => {\n        cacheMisses.sort();\n\n        this._cacheDebug(\n          `Ran (#${\n            ++this._callCount\n          }) on: ${\n            JSON.stringify(cacheMisses)\n          } ${\n            JSON.stringify(Object.keys(arches).sort())\n          }`\n        );\n      });\n    }\n  }\n\n  // Returns a hash that incorporates both this.getCacheKey(inputFile) and\n  // this.getAbsoluteImportPath(inputFile), since the file path might be\n  // relevant to the compiled output when using MultiFileCachingCompiler.\n  _getCacheKeyWithPath(inputFile) {\n    return this._deepHash([\n      this.getAbsoluteImportPath(inputFile),\n      this.getCacheKey(inputFile),\n    ]);\n  }\n\n  _cacheEntryValid(cacheEntry, cacheKeyMap) {\n    return Object.keys(cacheEntry.cacheKeys).every(\n      (path) => cacheEntry.cacheKeys[path] === cacheKeyMap.get(path)\n    );\n  }\n\n  // The format of a cache file on disk is the JSON-stringified cacheKeys\n  // object, a newline, followed by the CompileResult as returned from\n  // this.stringifyCompileResult.\n  _cacheFilename(cacheKey) {\n    return path.join(this._diskCache, cacheKey + \".cache\");\n  }\n\n  // Loads a {compileResult, cacheKeys} cache entry from disk. Returns the whole\n  // cache entry and loads it into the in-memory cache too.\n  _readCache(cacheKey) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const raw = this._readFileOrNull(cacheFilename);\n    if (!raw) {\n      return null;\n    }\n\n    // Split on newline.\n    const newlineIndex = raw.indexOf('\\n');\n    if (newlineIndex === -1) {\n      return null;\n    }\n    const cacheKeysString = raw.substring(0, newlineIndex);\n    const compileResultString = raw.substring(newlineIndex + 1);\n\n    const cacheKeys = this._parseJSONOrNull(cacheKeysString);\n    if (!cacheKeys) {\n      return null;\n    }\n    const compileResult = this.parseCompileResult(compileResultString);\n    if (! compileResult) {\n      return null;\n    }\n\n    const cacheEntry = {compileResult, cacheKeys};\n    this._cache.set(cacheKey, cacheEntry);\n    return cacheEntry;\n  }\n\n  _writeCacheAsync(cacheKey, cacheEntry) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const cacheContents =\n      JSON.stringify(cacheEntry.cacheKeys) + '\\n' +\n      this.stringifyCompileResult(cacheEntry.compileResult);\n    this._writeFile(cacheFilename, cacheContents);\n  }\n}\n"]}