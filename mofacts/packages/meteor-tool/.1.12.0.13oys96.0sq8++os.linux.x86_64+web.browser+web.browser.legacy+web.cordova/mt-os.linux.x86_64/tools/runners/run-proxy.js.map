{"version":3,"sources":["/tools/runners/run-proxy.js"],"names":["Anser","require","_","runLog","Proxy","options","self","listenPort","listenHost","proxyToPort","proxyToHost","onFailure","mode","httpQueue","websocketQueue","proxy","server","extend","prototype","start","Error","started","http","net","httpProxy","createProxyServer","agent","Agent","maxSockets","xfwd","createServer","req","res","push","_tryHandleConnections","on","socket","head","allowStart","promise","Promise","resolve","err","code","port","log","syscall","resOrSocket","logMessage","ServerResponse","headersSent","writeHead","end","Socket","listen","close","await","stop","each","c","statusCode","destroy","attempt","fn","e","length","shift","showErrorPage","web","target","ws","setMode","write","getLog","item","ansiToHtml","escapeForHtml","message","exports"],"mappings":"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","sourcesContent":["var Anser = require(\"anser\");\nvar _ = require('underscore');\nvar runLog = require('./run-log.js');\n\n// options: listenPort, proxyToPort, proxyToHost, onFailure\nvar Proxy = function (options) {\n  var self = this;\n\n  self.listenPort = options.listenPort;\n  self.listenHost = options.listenHost;\n  // note: run-all.js updates proxyToPort directly\n  self.proxyToPort = options.proxyToPort;\n  self.proxyToHost = options.proxyToHost || '127.0.0.1';\n  self.onFailure = options.onFailure || function () {};\n\n  self.mode = \"hold\";\n  self.httpQueue = []; // keys: req, res\n  self.websocketQueue = []; // keys: req, socket, head\n\n  self.proxy = null;\n  self.server = null;\n};\n\n_.extend(Proxy.prototype, {\n  // Start the proxy server, block (yield) until it is ready to go\n  // (actively listening on outer and proxying to inner), and then\n  // return.\n  start: function () {\n    var self = this;\n\n    if (self.server) {\n      throw new Error(\"already running?\");\n    }\n\n    self.started = false;\n\n    var http = require('http');\n    var net = require('net');\n    var httpProxy = require('http-proxy');\n\n    self.proxy = httpProxy.createProxyServer({\n      // agent is required to handle keep-alive, and http-proxy 1.0 is a little\n      // buggy without it: https://github.com/nodejitsu/node-http-proxy/pull/488\n      agent: new http.Agent({ maxSockets: 100 }),\n      xfwd: true\n    });\n\n    var server = self.server = http.createServer(function (req, res) {\n      // Normal HTTP request\n      self.httpQueue.push({ req: req, res: res });\n      self._tryHandleConnections();\n    });\n\n    self.server.on('upgrade', function (req, socket, head) {\n      // Websocket connection\n      self.websocketQueue.push({ req: req, socket: socket, head: head });\n      self._tryHandleConnections();\n    });\n\n    var allowStart;\n    var promise = new Promise(function (resolve) {\n      allowStart = resolve;\n    });\n\n    self.server.on('error', function (err) {\n      if (err.code === 'EADDRINUSE') {\n        var port = self.listenPort;\n        runLog.log(\n\"Can't listen on port \" + port + \". Perhaps another Meteor is running?\\n\" +\n\"\\n\" +\n\"Running two copies of Meteor in the same application directory\\n\" +\n\"will not work. If something else is using port \" + port + \", you can\\n\" +\n\"specify an alternative port with --port <port>.\");\n      } else if (self.listenHost &&\n                 (err.code === 'ENOTFOUND' || err.code === 'EADDRNOTAVAIL')) {\n        // This handles the case of \"entered a DNS name that's unknown\"\n        // (ENOTFOUND from getaddrinfo) and \"entered some random IP that we\n        // can't bind to\" (EADDRNOTAVAIL from listen).\n        runLog.log(\n\"Can't listen on host \" + self.listenHost + \" (\" + err.code + \" from \" +\n            err.syscall + \").\");\n\n      } else {\n        runLog.log('' + err);\n      }\n      self.onFailure();\n      allowStart();\n    });\n\n    // Don't crash if the app doesn't respond. instead return an error\n    // immediately. This shouldn't happen much since we try to not\n    // send requests if the app is down.\n    //\n    // Currently, this error is emitted if the proxy->server connection has an\n    // error (whether in HTTP or websocket proxying).  It is not emitted if the\n    // client->proxy connection has an error, though this may change; see\n    // discussion at https://github.com/nodejitsu/node-http-proxy/pull/488\n    self.proxy.on('error', function (err, req, resOrSocket) {\n      if (err.code === 'HPE_HEADER_OVERFLOW') {\n        const logMessage = 'Error during proxy to server communication ' +\n          'due to the header size exceeding Node\\'s currently ' +\n          'configured limit. This limit is configurable with a command ' +\n          'line option (https://nodejs.org/api/cli.html#cli_max_http_header_size_size ' +\n          'and https://docs.meteor.com/commandline.html#meteorrun).';\n        runLog.log(logMessage);\n      }\n\n      if (resOrSocket instanceof http.ServerResponse) {\n        if (!resOrSocket.headersSent) {\n          // Return a 503, but only if we haven't already written headers (or\n          // we'll get an ugly crash about rendering headers twice).  end()\n          // doesn't crash if called twice so we don't have to conditionalize\n          // that call.\n          resOrSocket.writeHead(503, {\n            'Content-Type': 'text/plain'\n          });\n        }\n        resOrSocket.end('Unexpected error.');\n      } else if (resOrSocket instanceof net.Socket) {\n        resOrSocket.end();\n      }\n    });\n\n    self.server.listen(self.listenPort, self.listenHost || '0.0.0.0', function () {\n      if (self.server) {\n        self.started = true;\n      } else {\n        // stop() got called while we were invoking listen! Close the server (we\n        // still have the var server). The rest of the cleanup shouldn't be\n        // necessary.\n        server.close();\n      }\n      allowStart();\n    });\n\n    promise.await();\n  },\n\n  // Idempotent.\n  stop: function () {\n    var self = this;\n\n    if (! self.server) {\n      return;\n    }\n\n    if (! self.started) {\n      // This probably means that we failed to listen. However, there could be a\n      // race condition and we could be in the middle of starting to listen! In\n      // that case, the listen callback will notice that we nulled out server\n      // here.\n      self.server = null;\n      return;\n    }\n\n    // This stops listening but allows existing connections to\n    // complete gracefully.\n    self.server.close();\n    self.server = null;\n\n    // It doesn't seem to be necessary to do anything special to\n    // destroy an httpProxy proxyserver object.\n    self.proxy = null;\n\n    // Drop any held connections.\n    _.each(self.httpQueue, function (c) {\n      c.res.statusCode = 500;\n      c.res.end();\n    });\n    self.httpQueue = [];\n\n    _.each(self.websocketQueue, function (c) {\n      c.socket.destroy();\n    });\n    self.websocketQueue = [];\n\n    self.mode = \"hold\";\n  },\n\n  _tryHandleConnections: function () {\n    var self = this;\n\n    function attempt(resOrSocket, fn) {\n      try {\n        return fn();\n      } catch (e) {\n        if (typeof resOrSocket.writeHead === \"function\") {\n          resOrSocket.writeHead(400, {\n            'Content-Type': 'text/plain'\n          });\n        }\n        resOrSocket.end(\"Bad request\\n\");\n      }\n    }\n\n    while (self.httpQueue.length) {\n      if (self.mode !== \"errorpage\" && self.mode !== \"proxy\") {\n        break;\n      }\n\n      var c = self.httpQueue.shift();\n      if (self.mode === \"errorpage\") {\n        showErrorPage(c.res);\n      } else {\n        attempt(c.res, () => self.proxy.web(c.req, c.res, {\n          target: 'http://' + self.proxyToHost + ':' + self.proxyToPort\n        }));\n      }\n    }\n\n    while (self.websocketQueue.length) {\n      if (self.mode !== \"proxy\") {\n        break;\n      }\n\n      var c = self.websocketQueue.shift();\n      attempt(c.socket, () => self.proxy.ws(c.req, c.socket, c.head, {\n        target: 'http://' + self.proxyToHost + ':' + self.proxyToPort\n      }));\n    }\n  },\n\n  // The proxy can be in one of three modes:\n  // - \"hold\": hold connections until the mode changes\n  // - \"proxy\": connections are proxied to the configured port\n  // - \"errorpage\": an error page is served to HTTP connections, and\n  //   websocket connections are held\n  //\n  // The initial mode is \"hold\".\n  setMode: function (mode) {\n    var self = this;\n    self.mode = mode;\n    self._tryHandleConnections();\n  }\n});\n\nfunction showErrorPage(res) {\n  // XXX serve an app that shows the logs nicely and that also\n  // knows how to reload when the server comes back up\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.write(`\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>App crashing</title>\n    <style type='text/css'>\n      body { margin: 0; }\n      h3 {\n        margin: 0;\n        font-family: sans-serif;\n        padding: 20px 10px 10px 10px;\n        background: #eee;\n      }\n      pre { margin: 20px; }\n    </style>\n  </head>\n\n  <body>\n    <h3>Your app is crashing. Here's the latest log:</h3>\n\n    <pre>`);\n\n      _.each(runLog.getLog(), function (item) {\n        res.write(Anser.ansiToHtml(Anser.escapeForHtml(item.message)) + \"\\n\");\n      });\n\n      res.write(`</pre>\n  </body>\n</html>`)\n\n  res.end();\n}\n\nexports.Proxy = Proxy;\n"],"file":"tools/runners/run-proxy.js.map"}