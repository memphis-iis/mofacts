{"version":3,"sources":["tools/utils/func-utils.ts"],"names":[],"mappings":"AAGA,MAAA,CAAA,MAAA,CAAA;AAAA,EAAA,QAAA,EAAA,MAAA;AAAA,CAAA;;AAGM,SAAU,QAAV,CACJ,OADI,EAEJ,QAFI,EAGJ,OAHI,EAGc;AAElB,MAAI,OAAO,GAAG,KAAd;AACA,MAAI,UAAU,GAAG,CAAjB;AAEA,QAAM,aAAa,GAAG,OAAO,IAAI,GAAjC;;AAEA,WAAS,iBAAT,GAA0B;AACxB,UAAM,IAAI,GAAG,OAAO,IAAI,IAAxB;;AAEA,QAAI,UAAJ,EAAgB;AACd;AACA;AACA,QAAE,UAAF;AACA;AACD;;AAED,QAAI,OAAJ,EAAa;AACX;AACA;AACD;;AAED,QAAI,OAAJ,CACE,OAAO,IAAI,UAAU,CAAC,OAAD,EAAU,aAAV,CADvB,EAEE,IAFF,CAEO,SAAS,YAAT,GAAqB;AAC1B;AACA;AACA;AACA;AACA;AACA,MAAA,OAAO,GAAG,KAAV;AACA,MAAA,UAAU,GAAG,CAAb;;AAEA,UAAI;AACF,QAAA,QAAQ,CAAC,IAAT,CAAc,IAAd;AACD,OAFD,SAEU;AACR,YAAI,UAAU,GAAG,CAAjB,EAAoB;AAClB,UAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,YAAvB;AACA,UAAA,OAAO,GAAG,IAAV;AACD;;AACD,QAAA,UAAU,GAAG,CAAb;AACD;AACF,KApBD;AAqBD;;AAED,SAAO,IAAI,CAAC,iBAAD,EAAoB,QAApB,CAAX;AACD;;AAAA;;AAED,SAAS,IAAT,CAGE,OAHF,EAGqB,OAHrB,EAGsC;AACpC;AACA;AACA,EAAA,OAAO,CAAC,SAAR,GAAoB,OAAO,CAAC,SAA5B,CAHoC,CAKpC;;AACA,QAAM,IAAI,GAAG,OAAO,CAAC,WAAR,IAAuB,OAAO,CAAC,IAA5C;;AACA,MAAI,IAAJ,EAAU;AACR,IAAA,OAAO,CAAC,WAAR,GAAsB,IAAtB;AACD;;AAED,SAAO,OAAP;AACD","sourcesContent":["type EmptyFunction = () => void;\ntype AnyFunction = (...args: any[]) => any;\n\n// Return a function that coalesceses calls to fn that occur within delay\n// milliseconds of each other, and prevents overlapping invocations of fn\n// by postponing the next invocation until after fn's fiber finishes.\nexport function coalesce<TContext>(\n  delayMs: number,\n  callback: EmptyFunction,\n  context?: TContext,\n): EmptyFunction {\n  let pending = false;\n  let inProgress = 0;\n\n  const actualDelayMs = delayMs || 100;\n\n  function coalescingWrapper(this: TContext) {\n    const self = context || this;\n\n    if (inProgress) {\n      // Indicate that coalescingWrapper should be called again after the\n      // callback is no longer in progress.\n      ++inProgress;\n      return;\n    }\n\n    if (pending) {\n      // Defer to the already-pending timer.\n      return;\n    }\n\n    new Promise(\n      resolve => setTimeout(resolve, actualDelayMs)\n    ).then(function thenCallback() {\n      // Now that the timeout has fired, set inProgress to 1 so that\n      // (until the callback is complete and we set inProgress to 0 again)\n      // any calls to coalescingWrapper will increment inProgress to\n      // indicate that at least one other caller wants fiberCallback to be\n      // called again when the original callback is complete.\n      pending = false;\n      inProgress = 1;\n\n      try {\n        callback.call(self);\n      } finally {\n        if (inProgress > 1) {\n          Promise.resolve().then(thenCallback);\n          pending = true;\n        }\n        inProgress = 0;\n      }\n    });\n  }\n\n  return wrap(coalescingWrapper, callback);\n};\n\nfunction wrap<\n  TWrapper extends AnyFunction,\n  TWrapped extends AnyFunction,\n>(wrapper: TWrapper, wrapped: TWrapped): TWrapper {\n  // Allow the wrapper to be used as a constructor function, just in case\n  // the wrapped function was meant to be used as a constructor.\n  wrapper.prototype = wrapped.prototype;\n\n  // https://medium.com/@cramforce/on-the-awesomeness-of-fn-displayname-9511933a714a\n  const name = wrapped.displayName || wrapped.name;\n  if (name) {\n    wrapper.displayName = name;\n  }\n\n  return wrapper;\n}\n"],"sourceRoot":"","file":"tools/utils/func-utils.js.map"}