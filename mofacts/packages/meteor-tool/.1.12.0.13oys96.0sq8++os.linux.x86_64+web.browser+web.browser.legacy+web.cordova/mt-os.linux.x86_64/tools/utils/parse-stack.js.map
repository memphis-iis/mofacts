{"version":3,"sources":["tools/utils/parse-stack.ts"],"names":[],"mappings":"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","sourcesContent":["type ParsedStackFrame = {\n  /**\n   * filename as it appears in the stack\n   */\n  file: string;\n\n  /**\n   * 1-indexed line in the file\n   */\n  line: number | null;\n\n  /**\n   * 1-indexed column in the line\n   */\n  column: number | null;\n\n  /**\n   * name of the function in the frame\n   */\n  func: string | null;\n};\n\n/**\n * Returns the stack associated with an error as an array.\n * More recently called functions appear first.\n * \n * Accomplishes this by parsing the text representation of the stack\n * with regular expressions. Unlikey to work anywhere but v8.\n * \n * If a function on the stack has been marked with mark(), will not\n * return anything past that function. We call this the \"user portion\"\n * of the stack.\n */\nexport function parse(err: Error): {\n  insideFiber?: ParsedStackFrame[],\n  outsideFiber?: ParsedStackFrame[],\n} {\n  const stack = err.stack;\n  if (typeof stack !== \"string\") {\n    return {};\n  }\n\n  // at least the first line is the exception\n  const frames = stack.split(\"\\n\").slice(1)\n    // longjohn adds lines of the form '---' (45 times) to separate\n    // the trace across async boundaries. It's not clear if we need to\n    // separate the trace in the same way we do for future boundaries below\n    // (it's not clear that that code is still useful either)\n    // so for now, we'll just remove such lines\n    .filter(f => ! f.match(/^\\-{45}$/));\n  \n  // \"    - - - - -\"\n  // This is something added when you throw an Error through a Future. The\n  // stack above the dashes is the stack of the 'wait' call; the stack below\n  // is the stack inside the fiber where the Error is originally\n  // constructed.\n  // XXX This code assumes that the stack trace can only be split once. It's not\n  // clear whether this can happen multiple times.\n  const indexOfFiberSplit = frames.indexOf('    - - - - -');\n\n  if (indexOfFiberSplit === -1) {\n    // This is a normal stack trace, not a split fiber stack trace\n    return {\n      outsideFiber: parseStackFrames(frames)\n    }\n  }\n\n  // If this is a split stack trace from a future, parse the frames above and\n  // below the split separately.\n  const outsideFiber = parseStackFrames(frames);\n  const insideFiber = parseStackFrames(frames.slice(indexOfFiberSplit + 1));\n\n  return {\n    insideFiber,\n    outsideFiber\n  };\n}\n\n/**\n * Decorator. Mark the point at which a stack trace returned by\n * parse() should stop: no frames earlier than this point will be\n * included in the parsed stack. Confusingly, in the argot of the\n * times, you'd say that frames \"higher up\" than this or \"above\" this\n * will not be returned, but you'd also say that those frames are \"at\n * the bottom of the stack\". Frames below the bottom are the outer\n * context of the framework running the user's code.\n */\nexport function markBottom(f: Function, context: any) {\n  /* eslint-disable camelcase */\n  return function __bottom_mark__() {\n    // @ts-ignore: Implicit this\n    return f.apply(context || this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\n/**\n * Decorator. Mark the point at which a stack trace returned by\n * parse() should begin: no frames later than this point will be\n * included in the parsed stack. The opposite of markBottom().\n * Frames above the top are helper functions defined by the\n * framework and executed by user code whose internal behavior\n * should not be exposed.\n */\nexport function markTop(f: Function, context: any) {\n  /* eslint-disable camelcase */\n  return function __top_mark__() {\n    // @ts-ignore: Implicit this\n    return f.apply(context || this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\nfunction parseStackFrames(frames: string[]): ParsedStackFrame[] {\n  let stop = false;\n  let parsedFrames: ParsedStackFrame[] = [];\n\n  frames.some(frame => {\n    if (stop) {\n      return true;\n    }\n\n    let m;\n\n    /* eslint-disable max-len */\n    if (m = frame.match(/^\\s*at\\s*((new )?.+?)\\s*(\\[as\\s*([^\\]]*)\\]\\s*)?\\((.*?)(:(\\d+))?(:(\\d+))?\\)\\s*$/)) {\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n      // \"    at My.Function (/path/to/myfile.js:532:39)\"\n      // \"    at Array.forEach (native)\"\n      // \"    at new My.Class (file.js:1:2)\"\n      // \"    at [object Object].main.registerCommand.name [as func] (meteor/tools/commands.js:1225:19)\"\n      // \"    at __top_mark__ [as matchErr] (meteor/tools/parse-stack.js:82:14)\"\n      //\n      // In that last example, it is not at all clear to me what the\n      // 'as' stanza refers to, but it is in m[3] if you find a use for it.\n      if (m[1].match(/(?:^|\\.)__top_mark__$/)) {\n        // m[1] could be Object.__top_mark__ or something like that\n        // depending on where exactly you put the function returned by\n        // markTop\n        parsedFrames = [];\n        return;\n      }\n\n      if (m[1].match(/(?:^|\\.)__bottom_mark__$/)) {\n        return stop = true;\n      }\n\n      parsedFrames.push({\n        func: m[1],\n        file: m[5],\n        line: m[7] ? +m[7] : null,\n        column: m[9] ? +m[9] : null\n      });\n      return;\n    }\n    /* eslint-enable max-len */\n\n    if (m = frame.match(/^\\s*at\\s+(.+?)(:(\\d+))?(:(\\d+))?\\s*$/)) {\n      // \"    at /path/to/myfile.js:532:39\"\n      parsedFrames.push({\n        file: m[1],\n        line: m[3] ? +m[3] : null,\n        column: m[5] ? +m[5] : null,\n        func: null,\n      });\n      return;\n    }\n\n    if (m = frame.match(/^\\s*-\\s*-\\s*-\\s*-\\s*-\\s*$/)) {\n      // Stop parsing if we reach a stack split from a Future\n      return stop = true;\n    }\n\n    if (frame.startsWith(\" => awaited here:\")) {\n      // The meteor-promise library inserts \" => awaited here:\" lines to\n      // indicate async boundaries.\n      return stop = true;\n    }\n\n    if (parsedFrames.length === 0) {\n      // We haven't found any stack frames, so probably we have newlines in the\n      // error message. Just skip this line.\n      return;\n    }\n\n    throw new Error(`Couldn't parse stack frame: '${frame}'`);\n  });\n\n  return parsedFrames;\n}\n"],"sourceRoot":"","file":"tools/utils/parse-stack.js.map"}