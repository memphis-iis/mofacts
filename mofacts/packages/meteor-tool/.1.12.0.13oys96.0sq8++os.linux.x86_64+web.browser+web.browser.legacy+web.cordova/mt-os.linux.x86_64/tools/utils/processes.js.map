{"version":3,"sources":["tools/utils/processes.ts"],"names":[],"mappings":"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","sourcesContent":["import child_process from 'child_process';\nimport { Writable } from 'stream';\nimport { convertToOSPath } from '../static-assets/server/mini-files';\n\n// The execFileSync function is meant to resemble the similarly-named Node 0.12\n// synchronous process creation API, but instead of being fully blocking it\n// uses a promise-based implementation. You can also use\n// execFileAsync directly, which returns a promise.\n// Some functionality is currently missing but could be added when the need\n// arises (e.g. support for timeout, maxBuffer, and encoding options).\n// Eventually, these versions should replace the ones in tools/utils/utils.js\n// and tools/tool-testing/selftest.js.\n\ntype ExecFileOptions = {\n  /**\n   * Current working directory of the child process\n   */\n  cwd?: string,\n\n  /**\n   * Environment key-value pairs\n   */\n  env?: NodeJS.ProcessEnv,\n\n  /**\n   * Child's stdio configuration.\n   * (Default: 'pipe') Specifying anything but 'pipe' will disallow capture.\n   */\n  stdio?: 'pipe' | Array<null | undefined | 'pipe'>,\n\n  /**\n   * If specified, instead of capturing the output, the child process stdout\n   * will be piped to the destination stream.\n   */\n  destination?: Writable,\n\n  /**\n   * Whether to wait for the child process streams to close or to resolve\n   * the promise when the child process exits.\n   */\n  waitForClose?: boolean,\n}\n\n /**\n  * @summary Executes a command synchronously, returning either the captured\n  * stdout output or throwing an error containing the stderr output as part of\n  * the message. In addition, the error will contain fields pid, stderr, stdout,\n  * status and signal.\n  * @param command The command to run\n  * @param args List of string arguments\n  * @param options \n  * @returns The stdout from the command\n  */\nexport function execFileSync(\n  command: string,\n  args?: ReadonlyArray<string> | ExecFileOptions,\n  options?: ExecFileOptions\n) {\n  const meteorPromise: any = Promise; // TypeScript doesn't recognize \"Promise.await\"\n  return meteorPromise.await(execFileAsync(command, args, options));\n}\n\n /**\n  * @summary Executes a command asynchronously, returning a promise that will\n  * either be resolved to the captured stdout output or be rejected with an\n  * error containing the stderr output as part of the message. In addition,\n  * the error will contain fields pid, stderr, stdout, status and signal.\n  * @param command The command to run\n  * @param args List of string arguments\n  * @param options \n  */\nexport function execFileAsync(\n  command: string,\n  args?: ReadonlyArray<string> | ExecFileOptions,\n  options: ExecFileOptions = { waitForClose: true }\n) {\n  // args is optional, so if it's not an array we interpret it as options\n  if (!Array.isArray(args)) {\n    options = {\n      ...options,\n      ...args,\n    }\n  }\n\n  if (options.cwd) {\n    options.cwd = convertToOSPath(options.cwd);\n  }\n\n  // The child process close event is emitted when the stdio streams\n  // have all terminated. If those streams are shared with other\n  // processes, that means we won't receive a 'close' until all processes\n  // have exited, so we may want to respond to 'exit' instead.\n  // (The downside of responding to 'exit' is that the streams may not be\n  // fully flushed, so we could miss captured output. Only use this\n  // option when needed.)\n  const exitEvent = options.waitForClose ? 'close' : 'exit';\n\n  return new Promise((resolve, reject) => {\n    let child: ReturnType<typeof child_process.exec>; \n    const spawnArgs: ReadonlyArray<string> = Array.isArray(args) ? args : [];\n    const { cwd, env, stdio } = options;\n\n    if (process.platform !== 'win32') {\n      child = child_process.spawn(command, spawnArgs, { cwd, env, stdio });\n    } else {\n      // https://github.com/nodejs/node-v0.x-archive/issues/2318\n      spawnArgs.forEach(arg => {\n        command += ' ' + arg;\n      });\n      child = child_process.exec(command, { cwd, env });\n    }\n\n    let capturedStdout = '';\n    if (child.stdout) {\n      if (options.destination) {\n        child.stdout.pipe(options.destination);\n      } else {\n        child.stdout.setEncoding('utf8');\n        child.stdout.on('data', (data: string) => {\n          capturedStdout += data;\n        });\n      }\n    }\n\n    let capturedStderr = '';\n    if (child.stderr) {\n      child.stderr.setEncoding('utf8');\n      child.stderr.on('data', (data: string) => {\n        capturedStderr += data;\n      });\n    }\n\n    const errorCallback = (error: NodeJS.ErrnoException) => {\n      // Make sure we only receive one type of callback\n      child.removeListener(exitEvent, exitCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      Object.assign(error, {\n        pid: child.pid,\n        stdout: capturedStdout,\n        stderr: capturedStderr,\n      });\n\n      // Set a more informative error message on ENOENT, that includes the\n      // command we attempted to execute\n      if (error.code === 'ENOENT') {\n        error.message = `Could not find command '${command}'`;\n      }\n\n      reject(error);\n    };\n    child.on('error', errorCallback);\n\n    const exitCallback = (code: number, signal: string) => {\n      // Make sure we only receive one type of callback\n      child.removeListener('error', errorCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      if (code === 0) {\n        resolve(capturedStdout);\n      } else {\n        let errorMessage = `Command failed: ${command}`;\n        if (spawnArgs) {\n          errorMessage += ` ${spawnArgs.join(' ')}`;\n        }\n        errorMessage += `\\n${capturedStderr}`;\n\n        const error = new Error(errorMessage);\n\n        Object.assign(error, {\n          pid: child.pid,\n          stdout: capturedStdout,\n          stderr: capturedStderr,\n          status: code,\n          signal: signal\n        })\n\n        reject(error);\n      }\n    };\n    child.on(exitEvent, exitCallback);\n  });\n}\n"],"sourceRoot":"","file":"tools/utils/processes.js.map"}