{"version":3,"sources":["tools/fs/watch.ts"],"names":[],"mappings":"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","sourcesContent":["import { Stats, FSWatcher, Dirent } from \"fs\";\nimport * as files from \"./files\";\nimport * as safeWatcher from \"./safe-watcher\";\nimport { createHash } from \"crypto\";\nimport { coalesce } from \"../utils/func-utils\";\nimport { Profile } from \"../tool-env/profile\";\nimport {\n  optimisticHashOrNull,\n  optimisticStatOrNull,\n} from \"./optimistic\";\n\nconst _ = require(\"underscore\");\n\nconst WATCH_COALESCE_MS =\n  +(process.env.METEOR_FILE_WATCH_COALESCE_MS || 100);\n\n// Watch for changes to a set of files, and the first time that any of\n// the files change, call a user-provided callback. (If you want a\n// second callback, you'll need to create a second Watcher.)\n//\n// You describe the structure you want to watch in a WatchSet; you then create a\n// Watcher to watch it. Watcher does not mutate WatchSet, so you can create\n// several Watchers from the same WatchSet. WatchSet can be easily converted to\n// and from JSON for serialization.\n//\n// You can set up two kinds of watches, file and directory watches.\n//\n// In a file watch, you provide an absolute path to a file and a SHA1 (encoded\n// as hex) of the contents of that file. If the file ever changes so that its\n// contents no longer match that SHA1, the callback triggers. You can also\n// provide `null` for the SHA1, which means the file should not exist.\n//\n// In a directory watch, you provide an absolute path to a directory,\n// two lists of regular expressions specifying the entries to\n// include and exclude, a list of specific names to include (which ignores\n// the exclude regexp list) and an array of which entries to expect.\n//\n// For directory watches, the regular expressions work as follows. You provide\n// two arrays of regular expressions, an include list and an exclude list. An\n// entry in the directory matches if it matches at least one regular expression\n// in the include list, and doesn't match any regular expressions in the exclude\n// list. The string that is matched against the regular expression ends with a\n// '/' if the entry is directory. There is NO IMPLICIT RECURSION here: a\n// directory watch ONLY watches the immediate children of the directory! If you\n// want a recursive watch, you need to do the recursive walk while building the\n// WatchSet and add a bunch of separate directory watches.  In addition, you\n// can provide a list of specific names to expect; these are not filtered\n// by the exclude list.  (For example, you might want to see all \"*.js\" files\n// but ignore files starting with dots (which are often temporary files), but\n// explicitly ask for \".jshintrc\".)\n//\n// There can be multiple directory watches on the same directory. There is no\n// relationship between the files found in directory watches and the files\n// watched by file watches; they are parallel mechanisms.\n//\n// Regular expressions are checked only against individual path components (the\n// actual name of the file or the subdirectory) plus the trailing '/' for\n// directories, not against the entire path.\n//\n// You can call stop() to stop watching and tear down the\n// watcher. Calling stop() guarantees that you will not receive a\n// callback (if you have not already). Calling stop() is unnecessary\n// if you've received a callback.\n//\n// To do a \"one-shot\" (to see if any files have been modified, compared to the\n// dependencies, at a particular point in time), use the isUpToDate function.\n//\n// XXX Symlinks are currently treated transparently: we treat them as the thing\n// they point to (ie, as a directory if they point to a directory, as\n// nonexistent if they point to something nonexist, etc). Not sure if this is\n// correct.\n\ntype DirectoryEntry = {\n  absPath: string;\n  include: RegExp[];\n  exclude: RegExp[];\n  names: string[];\n  contents: string[] | null;\n}\n\nexport class WatchSet {\n  // Set this to true if any Watcher built on this WatchSet must immediately\n  // fire (eg, if this WatchSet was given two different sha1 for the same file).\n  public alwaysFire = false;\n\n  // Map from the absolute path to a file, to a sha1 hash, or null if the file\n  // should not exist. A Watcher created from this set fires when the file\n  // changes from that sha, or is deleted (if non-null) or created (if null).\n  //\n  // Note that Isopack.getSourceFilesUnderSourceRoot() depends on this field\n  // existing (it's not just an internal implementation detail of watch.ts).\n  public readonly files: Record<string, string | null> = Object.create(null);\n\n  // This represents the assertion that 'absPath' is a directory and that\n  // 'contents' is its immediate contents, as filtered by the regular\n  // expressions.  Entries in 'contents' are file and subdirectory names;\n  // directory names end with '/'. 'contents' is sorted. An entry is in\n  // 'contents' if its value (including the slash, for directories) matches at\n  // least one regular expression in 'include' and no regular expressions in\n  // 'exclude'... or if it is in 'names'.\n  //\n  // There is no recursion here: files contained in subdirectories never appear.\n  //\n  // A directory may have multiple entries (presumably with different\n  // include/exclude filters).\n  public readonly directories: DirectoryEntry[] = [];\n\n  public addFile(filePath: string, hash: string | null) {\n    // Calling addFile directly instead of addPotentiallyUnusedFile implies\n    // that the file will be used, so we can mark it as such here. Note that\n    // addPotentiallyUnusedFile overrides this value based on the alreadyUsed\n    // variable after calling this.addFile.\n    this.potentiallyUnusedFiles.delete(filePath);\n\n    // No need to update if this is in always-fire mode already.\n    if (this.alwaysFire) {\n      return;\n    }\n\n    if (_.has(this.files, filePath)) {\n      // Redundant?\n      if (this.files[filePath] === hash) {\n        return;\n      }\n      // Nope, inconsistent.\n      this.alwaysFire = true;\n      return;\n    }\n\n    this.files[filePath] = hash;\n  }\n\n  public hasFile(filePath: string): boolean {\n    return _.has(this.files, filePath);\n  }\n\n  // Files added via addPotentiallyUnusedFile will be included in this Set\n  // until addFile is called at a later time, which removes them from the\n  // potentiallyUnusedFiles Set and prevents them from being considered as\n  // potentially unused in the future. Either way, this.files will have\n  // the same contents as if addFile was called instead, which is\n  // important for checks such as IsopackCache._checkUpToDate, which need\n  // to take everything (even potentially unused files) into account.\n  private potentiallyUnusedFiles = new Set<string>();\n\n  public isDefinitelyUsed(filePath: string): boolean {\n    return this.hasFile(filePath) && ! this.isPotentiallyUnused(filePath);\n  }\n\n  public isPotentiallyUnused(filePath: string): boolean {\n    return this.potentiallyUnusedFiles.has(filePath);\n  }\n\n  public addPotentiallyUnusedFile(filePath: string, hash: string | null) {\n    const alreadyUsed = this.isDefinitelyUsed(filePath);\n    this.addFile(filePath, hash);\n    if (! alreadyUsed) {\n      this.potentiallyUnusedFiles.add(filePath);\n    }\n  }\n\n  public addDirectory({\n    absPath,\n    include,\n    exclude,\n    names,\n    contents,\n  }: DirectoryEntry) {\n    if (this.alwaysFire) return;\n    if (_.isEmpty(include) && _.isEmpty(names)) {\n      return;\n    }\n    this.directories.push({\n      absPath,\n      include,\n      exclude,\n      names,\n      contents: contents && contents.slice(0).sort(),\n    });\n  }\n\n  // Merges another WatchSet into this one. This one will now fire if either\n  // WatchSet would have fired.\n  public merge(that: WatchSet) {\n    if (this.alwaysFire) return;\n    if (that.alwaysFire) {\n      this.alwaysFire = true;\n      return;\n    }\n\n    Object.keys(that.files).forEach(name => {\n      if (that.isPotentiallyUnused(name)) {\n        this.addPotentiallyUnusedFile(name, that.files[name]);\n      } else {\n        this.addFile(name, that.files[name]);\n      }\n    });\n\n    that.directories.forEach(dir => {\n      // XXX this doesn't deep-clone the directory, but I think these objects\n      // are never mutated #WatchSetShallowClone #TypeScriptOpportunity\n      this.directories.push(dir);\n    });\n  }\n\n  public clone() {\n    const ret = new WatchSet();\n\n    ret.alwaysFire = this.alwaysFire;\n\n    Object.keys(this.files).forEach(name => {\n      ret.files[name] = this.files[name];\n    });\n\n    this.potentiallyUnusedFiles.forEach(name => {\n      ret.potentiallyUnusedFiles.add(name);\n    });\n\n    // XXX doesn't bother to deep-clone the directory info\n    // #WatchSetShallowClone\n    this.directories.forEach(entry => {\n      ret.directories.push(entry);\n    });\n\n    return ret;\n  }\n\n  toJSON() {\n    if (this.alwaysFire) {\n      return { alwaysFire: true };\n    }\n\n    function reToJSON(r: RegExp) {\n      let options = '';\n      if (r.ignoreCase) {\n        options += 'i';\n      }\n      if (r.multiline) {\n        options += 'm';\n      }\n      if (r.global) {\n        options += 'g';\n      }\n      if (options) {\n        return {\n          $regex: r.source,\n          $options: options,\n        };\n      }\n      return r.source;\n    }\n\n    const potentiallyUnusedFiles: string[] = [];\n    this.potentiallyUnusedFiles.forEach(name => {\n      potentiallyUnusedFiles.push(name);\n    });\n\n    return {\n      files: this.files,\n      potentiallyUnusedFiles,\n      directories: this.directories.map(d => ({\n        absPath: d.absPath,\n        include: d.include.map(reToJSON),\n        exclude: d.exclude.map(reToJSON),\n        names: d.names,\n        contents: d.contents\n      })),\n    };\n  }\n\n  static fromJSON(json: any) {\n    const watchSet = new WatchSet();\n\n    if (! json) {\n      return watchSet;\n    }\n\n    if (json.alwaysFire) {\n      watchSet.alwaysFire = true;\n      return watchSet;\n    }\n\n    Object.keys(json.files).forEach(name => {\n      watchSet.files[name] = json.files[name];\n    });\n\n    if (Array.isArray(json.potentiallyUnusedFiles)) {\n      json.potentiallyUnusedFiles.forEach((name: string) => {\n        watchSet.potentiallyUnusedFiles.add(name);\n      });\n    }\n\n    function reFromJSON(j: any) {\n      if (j.$regex) {\n        return new RegExp(j.$regex, j.$options);\n      }\n      return new RegExp(j);\n    }\n\n    json.directories.forEach((d: any) => {\n      watchSet.directories.push({\n        absPath: d.absPath,\n        include: d.include.map(reFromJSON),\n        exclude: d.exclude.map(reFromJSON),\n        names: d.names,\n        contents: d.contents,\n      })\n    });\n\n    return watchSet;\n  }\n}\n\nexport function readFile(absPath: string) {\n  try {\n    return files.readFile(absPath);\n  } catch (e) {\n    // Rethrow most errors.\n    if (! e || (e.code !== 'ENOENT' && e.code !== 'EISDIR')) {\n      throw e;\n    }\n    // File does not exist (or is a directory).\n    return null;\n  }\n};\n\nexport const sha1 = Profile(\"sha1\", function (...args: (string | Buffer)[]) {\n  const hash = createHash('sha1');\n  args.forEach(arg => hash.update(arg));\n  return hash.digest('hex');\n});\n\nexport const sha512 = Profile(\"sha512\", function (...args: (string | Buffer)[]) {\n  const hash = createHash('sha512');\n  args.forEach(arg => hash.update(arg));\n  return hash.digest('base64');\n});\n\nfunction readAndStatDirectory(absPath: string) {\n  // Read the directory.\n  try {\n    var contents = files.readdirWithTypes(absPath);\n  } catch (e) {\n    // If the path is not a directory, return null; let other errors through.\n    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) {\n      return null;\n    }\n    throw e;\n  }\n\n  // Add slashes to the end of directories.\n  const contentsWithSlashes: string[] = [];\n  contents.forEach(entry => {\n    let stat: Dirent | Stats | null = entry;\n    let name = entry.name;\n\n    if (entry.isSymbolicLink()) {\n      // We do stat instead of lstat here, so that we treat symlinks to\n      // directories just like directories themselves.\n      stat = optimisticStatOrNull(files.pathJoin(absPath, entry.name));\n    }\n    if (! stat) {\n      // Disappeared after the readdir (or a dangling symlink)?\n      // Eh, pretend it was never there in the first place.\n      return;\n    }\n\n    if (stat.isDirectory()) {\n      name += '/';\n    }\n\n    contentsWithSlashes.push(name);\n  });\n\n  return contentsWithSlashes;\n}\n\nfunction filterDirectoryContents(contents: string[], {\n  include,\n  exclude,\n  names,\n}: {\n  include?: RegExp[],\n  exclude?: RegExp[],\n  names?: string[],\n}) {\n  // Filter based on regexps.\n  return contents.filter(entry => {\n    // Is it one of the names we explicitly requested?\n    if (names && names.indexOf(entry) !== -1) {\n      return true;\n    }\n    // Is it ruled out by an exclude rule?\n    if (exclude && exclude.some(re => re.test(entry))) {\n      return false;\n    }\n    // Is it ruled in by an include rule?\n    if (include && include.some(re => re.test(entry))) {\n      return true;\n    }\n    return false;\n  }).sort();\n}\n\nexport function readDirectory({ absPath, include, exclude, names }: {\n  absPath: string;\n  include?: RegExp[],\n  exclude?: RegExp[],\n  names?: string[],\n}) {\n  const contents = readAndStatDirectory(absPath);\n  return contents ? filterDirectoryContents(contents, {\n    include, exclude, names\n  }) : [];\n}\n\n// All fields are private.\nexport class Watcher {\n  private watchSet: WatchSet;\n  private onChange: () => any;\n  private stopped = false;\n  private justCheckOnce = false;\n  private async = false;\n  private includePotentiallyUnusedFiles = true;\n\n  private watches: Record<string, {\n    // Null until safeWatcher.watch succeeds in watching the file.\n    watcher: safeWatcher.SafeWatcher | null;\n    // Undefined until we stat the file for the first time, then null\n    // if the file is observed to be missing.\n    lastStat?: Stats | null\n  }> = Object.create(null);\n\n  constructor(options: {\n    watchSet: WatchSet;\n    onChange: () => any;\n    async?: boolean;\n    justCheckOnce?: boolean;\n    includePotentiallyUnusedFiles?: boolean;\n  }) {\n    this.async = !! options.async;\n    this.watchSet = options.watchSet;\n    this.onChange = options.onChange;\n    this.justCheckOnce = !! options.justCheckOnce;\n    if (options.includePotentiallyUnusedFiles === false) {\n      this.includePotentiallyUnusedFiles = false;\n    }\n\n    // Were we given an inconsistent WatchSet? Fire now and be done with it.\n    if (this.watchSet.alwaysFire) {\n      this.fire();\n      return;\n    }\n\n    this.startFileWatches();\n    this.checkDirectories();\n  }\n\n  private fireIfFileChanged(absPath: string) {\n    if (this.stopped) {\n      return true;\n    }\n\n    if (\n      ! this.includePotentiallyUnusedFiles &&\n      this.watchSet.isPotentiallyUnused(absPath)\n    ) {\n      return false;\n    }\n\n    const oldHash = this.watchSet.files[absPath];\n    if (typeof oldHash === \"undefined\") {\n      throw new Error(\"Checking unknown file \" + absPath);\n    }\n\n    const newHash = optimisticHashOrNull(absPath);\n    if (newHash === null) {\n      // File does not exist (or is a directory).\n      // Is this what we expected?\n      if (oldHash === null) {\n        return false;\n      }\n      // Nope, not what we expected.\n      this.fire();\n      return true;\n    }\n\n    // File exists! Is that what we expected?\n    if (oldHash === null) {\n      this.fire();\n      return true;\n    }\n\n    // Unchanged?\n    if (newHash === oldHash) {\n      return false;\n    }\n\n    this.fire();\n    return true;\n  }\n\n  // infos must all be for the same directory\n  private fireIfDirectoryChanged(infos: DirectoryEntry[]) {\n    if (this.stopped) {\n      return true;\n    }\n\n    const contents = readAndStatDirectory(infos[0].absPath);\n\n    for (const info of infos) {\n      const newContents = filterDirectoryContents(contents || [], info);\n\n      // If the directory has changed (including being deleted or created).\n      if (! _.isEqual(info.contents, newContents)) {\n        this.fire();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private startFileWatches() {\n    const keys = Object.keys(this.watchSet.files);\n\n    // Set up a watch for each file\n    this.processBatches(keys, absPath => {\n      if (! this.justCheckOnce) {\n        this.watchFileOrDirectory(absPath, true);\n      }\n\n      // Check for the case where by the time we created the watch,\n      // the file had already changed from the sha we were provided.\n      this.fireIfFileChanged(absPath);\n    });\n  }\n\n  private watchFileOrDirectory(absPath: string, skipCheck = false) {\n    if (! _.has(this.watches, absPath)) {\n      this.watches[absPath] = {\n        watcher: null,\n        // Initially undefined (instead of null) to indicate we have never\n        // called files.stat on this file before.\n        lastStat: undefined\n      };\n    }\n\n    const entry = this.watches[absPath];\n    if (entry.watcher) {\n      // Already watching this path.\n      return;\n    }\n\n    if (files.statOrNull(absPath)) {\n      if (this.mustNotExist(absPath)) {\n        this.fire();\n        return;\n      }\n\n      const onWatchEvent = this.makeWatchEventCallback(absPath);\n      entry.watcher = safeWatcher.watch(absPath, onWatchEvent);\n\n      if (!skipCheck) {\n        // If we successfully created the watcher, invoke the callback\n        // immediately, so that we examine this file at least once.\n        onWatchEvent();\n      } else {\n        this.updateStatForWatch(absPath);\n      }\n\n    } else {\n      if (this.mustBeAFile(absPath)) {\n        this.fire();\n        return;\n      }\n\n      const parentDir = files.pathDirname(absPath);\n      if (parentDir === absPath) {\n        throw new Error(\"Unable to watch parent directory of \" + absPath);\n      }\n\n      this.watchFileOrDirectory(parentDir);\n    }\n  }\n\n  private makeWatchEventCallback(absPath: string) {\n    // Sometimes we receive a rapid succession of change events, perhaps\n    // because several files were modified at once (e.g. by git reset\n    // --hard), or a file was deleted and then recreated by an editor like\n    // Vim. Because detecting changes can be costly, and because we care\n    // most about the settled state of the file system, we use the\n    // funcUtils.coalesce helper to delay calls to the callback by\n    // METEOR_FILE_WATCH_COALESCE_MS or 100 milliseconds, canceling any\n    // additional calls if they happen within that window of time, so that\n    // a rapid succession of calls will tend to trigger only one inspection\n    // of the file system.\n    return coalesce<WatchSet>(WATCH_COALESCE_MS, () => {\n      if (this.stopped) {\n        return;\n      }\n\n      // This helper method will call this._fire() if the old and new stat\n      // objects have different types (missing, file, or directory), so we\n      // can assume they have the same type for the rest of this method.\n      const stat = this.updateStatForWatch(absPath);\n      if (this.stopped) {\n        return;\n      }\n\n      if (stat === null || stat.isFile()) {\n        if (_.has(this.watchSet.files, absPath)) {\n          this.fireIfFileChanged(absPath);\n          // XXX #3335 We probably should check again in a second, due to low\n          // filesystem modtime resolution.\n        }\n\n      } else if (stat.isDirectory()) {\n        try {\n          var dirFiles = files.readdir(absPath);\n        } catch (err) {\n          if (err.code === \"ENOENT\" ||\n              err.code === \"ENOTDIR\") {\n            // The directory was removed or changed type since we called\n            // this._updateStatForWatch, so we fire unconditionally.\n            this.fire();\n            return;\n          }\n          throw err;\n        }\n\n        dirFiles.forEach(file => {\n          const fullPath = files.pathJoin(absPath, file);\n\n          // Recursively watch new files, if we ever previously tried to\n          // watch them. Recall that when we attempt to watch a\n          // non-existent file, we actually watch the closest enclosing\n          // directory that exists, so once the file (and/or any\n          // intermediate directories) are created, we begin watching\n          // those directories in response to change events fired for\n          // directories we're already watching.\n          if (_.has(this.watches, fullPath)) {\n            this.watchFileOrDirectory(fullPath);\n          }\n        });\n\n        // If this.watchSet.directories contains any entries for the\n        // directory we are examining, call this._fireIfDirectoryChanged.\n        const infos = this.watchSet.directories.filter(info => info.absPath === absPath );\n        if (infos.length) {\n          this.fireIfDirectoryChanged(infos);\n        }\n        // XXX #3335 We probably should check again in a second, due to low\n        // filesystem modtime resolution.\n      }\n    });\n  }\n\n  private mustNotExist(absPath: string) {\n    const wsFiles = this.watchSet.files;\n    if (_.has(wsFiles, absPath)) {\n      return wsFiles[absPath] === null;\n    }\n    return false;\n  }\n\n  private mustBeAFile(absPath: string) {\n    const wsFiles = this.watchSet.files;\n    if (_.has(wsFiles, absPath)) {\n      return _.isString(wsFiles[absPath]);\n    }\n    return false;\n  }\n\n  private updateStatForWatch(absPath: string) {\n    const entry = this.watches[absPath];\n    const lastStat = entry.lastStat;\n    let stat = files.statOrNull(absPath);\n    const mustNotExist = this.mustNotExist(absPath);\n    const mustBeAFile = this.mustBeAFile(absPath);\n\n    if (stat && lastStat === undefined) {\n      // We have not checked for this file before, so our expectations are\n      // somewhat relaxed (namely, we don't care about lastStat), but\n      // this._fire() might still need to be called if this.watchSet.files\n      // has conflicting expectations.\n      if (stat.isFile()) {\n        if (mustNotExist) {\n          this.fire();\n        }\n      } else if (stat.isDirectory()) {\n        if (mustNotExist || mustBeAFile) {\n          this.fire();\n        }\n      } else {\n        // Neither a file nor a directory, so treat as non-existent.\n        stat = null;\n        if (mustBeAFile) {\n          this.fire();\n        }\n      }\n\n      // We have not checked for this file before, so just record the new\n      // stat object.\n      entry.lastStat = stat;\n\n    } else if (stat && stat.isFile()) {\n      entry.lastStat = stat;\n      if (! lastStat || ! lastStat.isFile()) {\n        this.fire();\n      }\n\n    } else if (stat && stat.isDirectory()) {\n      entry.lastStat = stat;\n      if (! lastStat || ! lastStat.isDirectory()) {\n        this.fire();\n      }\n\n    } else {\n      entry.lastStat = stat = null;\n      if (lastStat) {\n        this.fire();\n      }\n    }\n\n    return stat;\n  }\n\n  // Iterates over the array, calling handleItem for each item\n  // When this._async is true, it pauses ocassionally to avoid blocking for too long\n  // Stops iterating after watcher is stopped\n  private processBatches<T>(\n    array: T[],\n    handleItem: (item: T) => any,\n  ) {\n    let index = 0;\n\n    const processBatch = () => {\n      const stopTime = this.async ? Date.now() + 50 : Infinity;\n      while (Date.now() < stopTime && index < array.length) {\n        if (this.stopped) {\n          return;\n        }\n\n        handleItem(array[index]);\n\n        index += 1;\n      }\n\n      if (index < array.length) {\n        if (this.async) {\n          setImmediate(processBatch);\n        } else {\n          processBatch();\n        }\n      }\n    }\n\n    processBatch();\n  }\n\n  private checkDirectories() {\n    const dirs = Object.values(this.watchSet.directories.reduce((result, dir) => {\n      const dirs = result[dir.absPath];\n      if (dirs) {\n        dirs.push(dir);\n      } else {\n        result[dir.absPath] = [dir];\n      }\n      return result;\n    }, {} as Record<string, DirectoryEntry[]>));\n\n    if (this.stopped) {\n      return;\n    }\n\n    this.processBatches(dirs, entries => {\n      if (! this.justCheckOnce) {\n        this.watchFileOrDirectory(entries[0].absPath, true);\n      }\n\n      // Check for the case where by the time we created the watch, the\n      // directory has already changed.\n      this.fireIfDirectoryChanged(entries);\n    });\n  }\n\n  private fire() {\n    if (this.stopped) return;\n    this.stop();\n    this.onChange();\n  }\n\n  stop() {\n    this.stopped = true;\n    // Clean up file watches\n    _.each(this.watches, function (entry: { watcher: FSWatcher | null }) {\n      if (entry.watcher) {\n        entry.watcher.close();\n        entry.watcher = null;\n      }\n    });\n    this.watches = Object.create(null);\n  }\n}\n\n// Given a WatchSet, returns true if it currently describes the state of the\n// disk.\nexport function isUpToDate(\n  watchSet: WatchSet,\n  includePotentiallyUnusedFiles = true\n) {\n  return Profile.time('watch.isUpToDate', () => {\n    let upToDate = true;\n    const watcher = new Watcher({\n      watchSet: watchSet,\n      onChange() {\n        upToDate = false;\n      },\n      // internal flag which prevents us from starting watches and timers that\n      // we're about to cancel anyway\n      justCheckOnce: true,\n      includePotentiallyUnusedFiles,\n    });\n    watcher.stop();\n    return upToDate;\n  });\n}\n\n// Options should have absPath/include/exclude/names.\nexport function readAndWatchDirectory(\n  watchSet: WatchSet,\n  options: DirectoryEntry,\n) {\n  const contents = readDirectory(options);\n  watchSet.addDirectory({\n    contents,\n    ...options,\n  });\n  return contents;\n}\n\n// Calculating the sha hash can be expensive for large files.  By\n// returning the calculated hash along with the file contents, the\n// hash doesn't need to be calculated again for static files.\n//\n// We only calculate the hash if needed here, so callers must not\n// *rely* on the hash being returned; merely that if the hash is\n// present, it is the correct hash of the contents.\nexport function readAndWatchFileWithHash(watchSet: WatchSet, absPath: string) {\n  const result: {\n    contents: string | Buffer | null;\n    hash: string | null;\n  } = {\n    contents: null,\n    hash: null,\n  };\n\n  try {\n    result.contents = files.readFile(absPath);\n  } catch (e) {\n    if (e && e.code === \"EISDIR\") {\n      // Avoid adding directories to the watchSet as files.\n      return result;\n    }\n\n    if (e && e.code === \"ENOENT\") {\n      // Continue, leaving result.{contents,hash} both null.\n    } else {\n      // Throw all other errors.\n      throw e;\n    }\n  }\n\n  if (result.contents !== null) {\n    result.hash = sha1(result.contents);\n  }\n\n  // Allow null watchSet, if we want to use readFile-style error handling in a\n  // context where we might not always have a WatchSet (eg, reading\n  // settings.json where we watch for \"meteor run\" but not for \"meteor deploy\").\n  if (watchSet) {\n    watchSet.addFile(absPath, result.hash);\n  }\n\n  return result;\n}\n\nexport function readAndWatchFile(watchSet: WatchSet, absPath: string) {\n  return readAndWatchFileWithHash(watchSet, absPath).contents;\n}\n"],"sourceRoot":"","file":"tools/fs/watch.js.map"}