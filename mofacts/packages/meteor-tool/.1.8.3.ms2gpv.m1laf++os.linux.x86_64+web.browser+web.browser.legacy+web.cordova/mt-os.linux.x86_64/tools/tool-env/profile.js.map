{"version":3,"sources":["tools/tool-env/profile.ts"],"names":[],"mappings":"AAAA,MAAA,CAAA,MAAA,CAAA;AAAA,EAAA,OAAgB,EAAA,MAAA;AAAhB,CAAA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAM,KAAK,GAAG,OAAO,CAAC,QAAD,CAArB;;AAEA,MAAM,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,GAAR,CAAY,cAAZ,IAA8B,KAA/B,CAAzB,C,CAAgE;;AAQhE,IAAI,WAAW,GAA0B,MAAM,CAAC,MAAP,CAAc,IAAd,CAAzC;AAEA,IAAI,UAAU,GAAG,GAAjB,C,CACA;;AACA,SAAS,MAAT,CAAgB,GAAhB,EAA2B;AACzB,SAAO,UAAU,CAAC,MAAX,GAAoB,GAA3B,EAAgC;AAC9B,IAAA,UAAU,GAAG,UAAU,GAAG,UAA1B;AA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","sourcesContent":["// Tiny profiler\n//\n// Enable by setting the environment variable `METEOR_PROFILE`.\n//\n// The main entry point is `Profile`, which wraps an existing function\n// and returns a new function which, when called, calls the original\n// function and profiles it.\n//\n// before:\n//\n//     foo: function (a) {\n//       return a + this.b;\n//     },\n//\n// after:\n//\n//     foo: Profile(\"foo\", function (a) {\n//       return a + this.b;\n//     }),\n//\n// The advantage of this form is that it doesn't change the\n// indentation of the wrapped code, which makes merging changes from\n// other code branches easier.\n//\n// If profiling is disabled (if `METEOR_PROFILE` isn't set), `Profile`\n// simply returns the original function.\n//\n// To run a profiling session and print the report, call `Profile.run`:\n//\n//     var createBundle = function () {\n//       Profile.run(\"bundle\", function () {\n//         ...code to create the bundle which includes calls to `Profile`.\n//       });\n//     };\n//\n// Code is not profiled when called outside of a `Profile.run`, so the\n// times in the report only include the time spent inside of the call\n// to `Profile.run`.\n//\n// Sometimes you'll want to use a name for the profile bucket which\n// depends on the arguments passed to the function or the value of\n// `this`.  In this case you can pass a function for the bucket\n// argument, which will be called to get the bucket name.\n//\n// before:\n//     build: function (target) {\n//       ... build target ...\n//     },\n//\n// after:\n//     build: Profile(\n//       function (target) { return \"build \" + target; },\n//       function (target) {\n//         ... build target ...\n//       }),\n//\n// But if it's easier, you can use `Profile.time` instead, which\n// immediately calls the passed function with no arguments and\n// profiles it, and returns what the function returns.\n//\n//     foo: function (a) {\n//       var self = this;\n//       return Profile.time(\"foo\", function () {\n//         return a + self.b;\n//       });\n//     },\n//\n//     build: function (target) {\n//       var self = this;\n//       self.doSomeSetup();\n//       Profile.time(\"build \" + target, function () {\n//         ... build target ...\n//       });\n//       self.doSomeCleanup();\n//     },\n//\n// The disadvantage is that you end up changing the indentation of the\n// profiled code, which makes merging branches more painful.  But you\n// can profile anywhere in the code; you don't have to just profile at\n// function boundaries.\n//\n// Note profiling code will itself add a bit of execution time.\n// If you profile in a tight loop and your total execution time is\n// going up, you're probably starting to profile how long it takes to\n// profile things :).\n//\n// If another profile (such as \"compile js\") is called while the first\n// function is currently being profiled, this creates an entry like\n// this:\n//\n//    build client : compile js\n//\n// which can continue to be nested, e.g.,\n//\n//    build client : compile js : read source files\n//\n// The total time reported for a bucket such as \"build client\" doesn't\n// change regardless of whether it has child entries or not.  However,\n// if an entry has child entries, it automatically gets an \"other\"\n// entry:\n//\n//     build client: 400.0\n//       compile js: 300.0\n//         read source files: 20.0\n//         other compile js: 280.0\n//       other build client: 100.0\n//\n// The \"other\" entry reports how much time was spent in the \"build\n// client\" entry not spent in the other child entries.\n//\n// The are two reports displayed: the hierarchical report and the\n// leaf time report.  The hierarchical report looks like the example\n// above and shows how much time was spent in each entry within its\n// parent entry.\n//\n// The primary purpose of the hierarchical report is to be able to see\n// where times are unaccounted for.  If you see a lot of time being\n// spent in an \"other\" bucket, and you don't know what it is, you can\n// add more profiling to dig deeper.\n//\n// The leaf time report shows the total time spent within leaf\n// buckets.  For example, if if multiple steps have \"read source\n// files\", the leaf time reports shows the total amount of time spent\n// in \"read source files\" across all calls.\n//\n// Once you see in the hierarchical report that you have a good handle\n// on accounting for most of the time, the leaf report shows you which\n// buckets are the most expensive.\n//\n// By only including leaf buckets, the times in the leaf report are\n// non-overlapping.  (The total of the times equals the elapsed time\n// being profiled).\n//\n// For example, suppose \"A\" is profiled for a total time of 200ms, and\n// that includes a call to \"B\" of 150ms:\n//\n//     B: 150\n//     A (without B): 50\n//\n// and suppose there's another call to \"A\" which *doesn't* include a\n// call to \"B\":\n//\n//     A: 300\n//\n// and there's a call to \"B\" directly:\n//\n//     B: 100\n//\n// All for a total time of 600ms.  In the hierarchical report, this\n// looks like:\n//\n//     A: 500.0\n//       B: 150.0\n//       other A: 350.0\n//     B: 100.0\n//\n// and in the leaf time report:\n//\n//     other A: 350.0\n//     B: 250.0\n//\n// In both reports the grand total is 600ms.\n\nconst Fiber = require('fibers');\n\nconst filter = parseFloat(process.env.METEOR_PROFILE || \"100\"); // ms\n\ntype Stats = {\n  time: number;\n  count: number;\n  isOther: boolean;\n}\n\nlet bucketStats: Record<string, Stats> = Object.create(null);\n\nlet SPACES_STR = ' ';\n// return a string of `x` spaces\nfunction spaces(len: number) {\n  while (SPACES_STR.length < len) {\n    SPACES_STR = SPACES_STR + SPACES_STR;\n  }\n  return SPACES_STR.slice(0, len);\n}\n\nlet DOTS_STR = '.';\n// return a string of `x` dots\nfunction dots(len: number) {\n  while (DOTS_STR.length < len) {\n    DOTS_STR = DOTS_STR + DOTS_STR;\n  }\n  return DOTS_STR.slice(0, len);\n}\n\nfunction leftRightAlign(str1: string, str2: string, len: number) {\n  var middle = Math.max(1, len - str1.length - str2.length);\n  return str1 + spaces(middle) + str2;\n}\n\nfunction leftRightDots(str1: string, str2: string, len: number) {\n  var middle = Math.max(1, len - str1.length - str2.length);\n  return str1 + dots(middle) + str2;\n}\n\nfunction printIndentation(isLastLeafStack: boolean[]) {\n  if (!isLastLeafStack.length) {\n    return '';\n  }\n\n  const { length } = isLastLeafStack;\n  let init = '';\n  for (let i = 0; i < length - 1; ++i) {\n    const isLastLeaf = isLastLeafStack[i];\n    init += isLastLeaf ? '   ' : '│  ';\n  }\n\n  const last = isLastLeafStack[length - 1] ? '└─ ' : '├─ ';\n\n  return init + last;\n}\n\nfunction formatMs(n: number) {\n  // integer with thousands separators\n  return String(Math.round(n)).replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\") + \" ms\";\n}\n\nfunction encodeEntryKey(entry: string[]) {\n  return entry.join('\\t');\n}\n\nfunction decodeEntryKey(key: string) {\n  return key.split('\\t');\n}\n\nconst globalEntry: string[] = [];\nlet running = false;\n\nexport function Profile<\n  TArgs extends any[],\n  TResult,\n>(\n  bucketName: string | ((...args: TArgs) => string),\n  f: (...args: TArgs) => TResult,\n): typeof f {\n  if (! Profile.enabled) {\n    return f;\n  }\n\n  return Object.assign(function profileWrapper(this: any) {\n    if (! running) {\n      return f.apply(this, arguments as any);\n    }\n\n    const name = typeof bucketName === \"function\"\n      ? bucketName.apply(this, arguments as any)\n      : bucketName;\n\n    const currentEntry = Fiber.current\n      ? Fiber.current.profilerEntry || (Fiber.current.profilerEntry = [])\n      : globalEntry;\n\n    currentEntry.push(name);\n    const key = encodeEntryKey(currentEntry);\n    const start = process.hrtime();\n    try {\n      return f.apply(this, arguments as any);\n    } finally {\n      const elapsed = process.hrtime(start);\n      const stats = (bucketStats[key] || (bucketStats[key] = {\n        time: 0.0,\n        count: 0,\n        isOther: false,\n      }));\n      stats.time += (elapsed[0] * 1000 + elapsed[1] / 1000000);\n      stats.count++;\n      currentEntry.pop();\n    }\n  }, f) as typeof f;\n}\n\nexport namespace Profile {\n  export let enabled = !! process.env.METEOR_PROFILE;\n\n  export function time<TResult>(bucket: string, f: () => TResult) {\n    return Profile(bucket, f)();\n  }\n\n  export function run<TResult>(bucket: string, f: () => TResult) {\n    if (! Profile.enabled) {\n      return f();\n    }\n\n    if (running) {\n      // We've kept the calls to Profile.run in the tool disjoint so far,\n      // and should probably keep doing so, but if we mess up, warn and continue.\n      console.log(\"Warning: Nested Profile.run at \" + bucket);\n      return time(bucket, f);\n    }\n\n    runningName = bucket;\n    print(`(#${reportNum}) Profiling: ${runningName}`);\n    start();\n    try {\n      return time(bucket, f);\n    } finally {\n      report();\n      reportNum++;\n    }\n  }\n\n  function start() {\n    bucketStats = {};\n    running = true;\n  }\n\n  let runningName: string;\n  let reportNum = 1;\n  function report() {\n    if (! Profile.enabled) {\n      return;\n    }\n    running = false;\n    print('');\n    setupReport();\n    reportHierarchy();\n    print('');\n    reportHotLeaves();\n    print('');\n    print(`(#${reportNum}) Total: ${formatMs(getTopLevelTotal())}` +\n          ` (${runningName})`);\n    print('');\n  }\n}\n\ntype Entry = string[];\nlet entries: Entry[] = [];\n\nconst prefix = \"| \";\n\nfunction entryName(entry: Entry) {\n  return entry[entry.length - 1];\n}\n\nfunction entryStats(entry: Entry) {\n  return bucketStats[encodeEntryKey(entry)];\n}\n\nfunction entryTime(entry: Entry) {\n  return entryStats(entry).time;\n}\n\nfunction isTopLevelEntry(entry: Entry) {\n  return entry.length === 1;\n}\n\nfunction topLevelEntries() {\n  return entries.filter(isTopLevelEntry);\n}\n\nfunction print(text: string) {\n  console.log(prefix + text);\n}\n\nfunction isChild(entry1: Entry, entry2: Entry) {\n  if (entry2.length !== entry1.length + 1) {\n    return false;\n  }\n  for (var i = entry1.length - 1; i >= 0; i--) {\n    if (entry1[i] !== entry2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction children(entry1: Entry) {\n  return entries.filter(entry2 => isChild(entry1, entry2));\n}\n\nfunction hasChildren(entry: Entry) {\n  return children(entry).length > 0;\n}\n\nfunction hasSignificantChildren(entry: Entry) {\n  return children(entry).some(entry => entryTime(entry) >= filter);\n}\n\nfunction isLeaf(entry: Entry) {\n  return ! hasChildren(entry);\n}\n\nfunction otherTime(entry: Entry) {\n  let total = 0;\n  children(entry).forEach(child => {\n    total += entryTime(child);\n  });\n  return entryTime(entry) - total;\n}\n\nfunction injectOtherTime(entry: Entry) {\n  const other: Entry = entry.slice(0);\n  other.push(\"other \" + entryName(entry));\n  bucketStats[encodeEntryKey(other)] = {\n    time: otherTime(entry),\n    count: entryStats(entry).count,\n    isOther: true\n  };\n  entries.push(other);\n};\n\nfunction reportOn(entry: Entry, isLastLeafStack: boolean[] = []) {\n  const stats = entryStats(entry);\n  const isParent = hasSignificantChildren(entry);\n  const name = entryName(entry);\n\n  print((isParent ? leftRightDots : leftRightAlign)\n        (printIndentation(isLastLeafStack) + name, formatMs(stats.time), 70)\n        + (stats.isOther ? \"\" : (\" (\" + stats.count + \")\")));\n\n  if (isParent) {\n    const childrenList = children(entry).filter(entry => {\n      return entryStats(entry).time > filter;\n    });\n    childrenList.forEach((child, i) => {\n      const isLastLeaf = i === childrenList.length - 1;\n      reportOn(child, isLastLeafStack.concat(isLastLeaf));\n    });\n  }\n}\n\nfunction reportHierarchy() {\n  topLevelEntries().forEach(entry => reportOn(entry));\n}\n\nfunction allLeafs() {\n  const set: { [name: string]: any } = Object.create(null);\n  entries.filter(isLeaf).map(entryName).forEach(name => set[name] = true);\n  return Object.keys(set).sort();\n}\n\nfunction leafTotals(leafName: string) {\n  let time = 0;\n  let count = 0;\n\n  entries.filter(entry => {\n    return entryName(entry) === leafName && isLeaf(entry);\n  }).forEach(leaf => {\n    const stats = entryStats(leaf);\n    time += stats.time;\n    count += stats.count;\n  });\n\n  return { time, count };\n}\n\nfunction reportHotLeaves() {\n  print('Top leaves:');\n\n  const totals = allLeafs().map(leaf => {\n    const info = leafTotals(leaf);\n    return {\n      name: leaf,\n      time: info.time,\n      count: info.count,\n    };\n  }).sort((a, b) => {\n    return a.time === b.time ? 0 : a.time > b.time ? -1 : 1;\n  });\n\n  totals.forEach(total => {\n    if (total.time < 100) { // hard-coded larger filter to quality as \"hot\" here\n      return;\n    }\n    print(leftRightDots(total.name, formatMs(total.time), 65) + ` (${total.count})`);\n  });\n}\n\nfunction getTopLevelTotal() {\n  let topTotal = 0;\n  topLevelEntries().forEach(entry => {\n    topTotal += entryTime(entry);\n  });\n  return topTotal;\n}\n\nfunction setupReport() {\n  entries = Object.keys(bucketStats).map(decodeEntryKey);\n  entries.filter(hasSignificantChildren).forEach(parent => {\n    injectOtherTime(parent);\n  });\n}\n"],"sourceRoot":"","file":"tools/tool-env/profile.js.map"}