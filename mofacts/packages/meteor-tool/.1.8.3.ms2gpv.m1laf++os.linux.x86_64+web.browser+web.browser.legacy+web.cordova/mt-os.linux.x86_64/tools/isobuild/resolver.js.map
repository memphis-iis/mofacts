{"version":3,"sources":["tools/isobuild/resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  isString,\n  isObject,\n  has,\n} from \"underscore\";\n\nimport { matches as archMatches, isLegacyArch } from \"../utils/archinfo\";\nimport {\n  pathJoin,\n  pathRelative,\n  pathNormalize,\n  pathDirname,\n  pathBasename,\n  convertToOSPath,\n  convertToPosixPath,\n} from \"../fs/files\";\nimport { Stats } from \"fs\";\nimport { wrap } from \"optimism\";\nimport {\n  optimisticStatOrNull,\n  optimisticReadJsonOrNull,\n} from \"../fs/optimistic\";\n\nconst nativeModulesMap: Record<string, string> = Object.create(null);\nconst nativeNames = Object.keys((process as any).binding(\"natives\"));\n\n// Node 0.10 does not include process as a built-in module, but later\n// versions of Node do, and we provide a stub for it on the client.\nnativeNames.push(\"process\");\n\nnativeNames.forEach(id => {\n  if (id.startsWith(\"internal/\")) {\n    return;\n  }\n\n  // When a native Node module is imported, we register a dependency on a\n  // meteor-node-stubs/deps/* module of the same name, so that the\n  // necessary stub modules will be included in the bundle. This alternate\n  // identifier will not be imported at runtime, but the modules it\n  // depends on are necessary for the original import to succeed.\n  nativeModulesMap[id] =  \"meteor-node-stubs/deps/\" + id;\n});\n\nexport type ResolverOptions = {\n  sourceRoot: string;\n  targetArch: string;\n  extensions: string[];\n  nodeModulesPaths: string[];\n  caller?: string;\n}\n\nexport type Resolution = {\n  stat: Stats;\n  path: string;\n  packageJsonMap?: Record<string, Record<string, any>>;\n  id?: string;\n} | \"missing\" | null\n\nexport default class Resolver {\n  static getOrCreate = wrap(function (options: ResolverOptions) {\n    return new Resolver(options);\n  }, {\n    makeCacheKey(options) {\n      return JSON.stringify(options);\n    }\n  });\n\n  private sourceRoot: string;\n  private targetArch: string;\n  private extensions: string[];\n  private nodeModulesPaths: string[];\n  private mainFields: string[];\n\n  public statOrNull = optimisticStatOrNull as (path: string) => Stats | null;\n\n  constructor({\n    sourceRoot,\n    targetArch,\n    extensions = [\".js\", \".json\"],\n    nodeModulesPaths = [],\n  }: ResolverOptions) {\n    this.sourceRoot = sourceRoot;\n    this.extensions = extensions;\n    this.targetArch = targetArch;\n    this.nodeModulesPaths = nodeModulesPaths;\n    this.statOrNull = optimisticStatOrNull;\n\n    const { resolve } = this;\n    this.resolve = wrap((id, absParentPath) => {\n      return resolve.call(this, id, absParentPath);\n    }, {\n      makeCacheKey(id, absParentPath) {\n        // Only the directory of the absParentPath matters for caching.\n        return JSON.stringify([id, pathDirname(absParentPath)]);\n      }\n    });\n\n    const {\n      findPkgJsonSubsetForPath,\n      getPkgJsonSubsetForDir,\n    } = this;\n\n    this.findPkgJsonSubsetForPath = wrap(\n      path => findPkgJsonSubsetForPath.call(this, path));\n\n    this.getPkgJsonSubsetForDir = wrap(\n      path => getPkgJsonSubsetForDir.call(this, path));\n\n    if (archMatches(this.targetArch, \"web\")) {\n      if (isLegacyArch(this.targetArch)) {\n        // The legacy bundle prefers the \"main\" field over the \"module\"\n        // field, since many npm packages ship modern syntax other than\n        // import/export in their \"module\" dependency trees.\n        this.mainFields = [\"browser\", \"main\", \"module\"];\n      } else {\n        this.mainFields = [\"browser\", \"module\", \"main\"];\n      }\n    } else {\n      this.mainFields = [\"main\"];\n    }\n  }\n\n  static isTopLevel(id: string) {\n    return \"./\".indexOf(id.charAt(0)) < 0;\n  }\n\n  static isNative(id: string): boolean {\n    return has(nativeModulesMap, id);\n  }\n\n  static getNativeStubId(id: string) {\n    return nativeModulesMap[id] || null;\n  }\n\n  // Resolve the given module identifier to an object { path, stat } or\n  // null, relative to an absolute parent path. The _seenDirPaths\n  // parameter is for internal use only and should be ommitted.\n  public resolve(\n    id: string,\n    absParentPath: string,\n    _seenDirPaths?: Set<string>,\n  ): Resolution {\n    let resolved =\n      this.resolveAbsolute(id, absParentPath) ||\n      this.resolveRelative(id, absParentPath) ||\n      this.resolveNodeModule(id, absParentPath);\n\n    if (resolved === \"missing\") {\n      // The _resolveNodeModule method can return \"missing\" to indicate\n      // that the ImportScanner should look elsewhere for this module,\n      // such as in the app node_modules directory.\n      return resolved;\n    }\n\n    let packageJsonMap = null;\n\n    while (resolved && resolved.stat && resolved.stat.isDirectory()) {\n      let dirPath = resolved.path;\n      _seenDirPaths = _seenDirPaths || new Set;\n\n      // If the \"main\" field of a package.json file resolves to a\n      // directory we've already considered, then we should not attempt to\n      // read the same package.json file again.\n      if (! _seenDirPaths.has(dirPath)) {\n        _seenDirPaths.add(dirPath);\n\n        const found = this.getPkgJsonSubsetForDir(dirPath);\n        const foundPkgJsonMain = found && this.mainFields.some(name => {\n          const value = found.pkg[name];\n          if (isString(value)) {\n            // The \"main\" field of package.json does not have to begin with ./\n            // to be considered relative, so first we try simply appending it\n            // to the directory path before falling back to a full resolve,\n            // which might return a package from a node_modules directory.\n            resolved = this.joinAndStat(dirPath, value) ||\n              this.resolve(value, found.path, _seenDirPaths);\n            return resolved && typeof resolved === \"object\";\n          }\n          return false;\n        });\n\n        if (foundPkgJsonMain && found) {\n          if (! resolved.packageJsonMap) {\n            resolved.packageJsonMap = Object.create(null);\n          }\n\n          resolved.packageJsonMap![found.path] = found.pkg;\n\n          // The resolution above may have returned a directory, so we\n          // merge resolved.packageJsonMap into packageJsonMap so that we\n          // don't forget the package.json we just resolved, then continue\n          // the loop to make sure we fully resolve the \"main\" module\n          // identifier to a non-directory.  Technically this could\n          // involve even more package.json files, but in practice the\n          // \"main\" property will almost always name a directory\n          // containing an index.js file.\n          Object.assign(\n            packageJsonMap || (packageJsonMap = Object.create(null)),\n            resolved.packageJsonMap,\n          );\n\n          continue;\n        }\n\n        // Include the package.json stub in the bundle even if it was not\n        // used to resolve the \"main\" entry point, per this comment:\n        // https://github.com/meteor/meteor/issues/9235#issuecomment-340562285\n        if (found) {\n          packageJsonMap = packageJsonMap || Object.create(null);\n          packageJsonMap[found.path] = found.pkg;\n        }\n      }\n\n      // If we didn't find a `package.json` file, or it didn't have a\n      // resolvable `.main` property, the only possibility left to\n      // consider is that this directory contains an `index.js` module.\n      // This assignment almost always terminates the while loop, because\n      // there's very little chance an `index.js` file will be a\n      // directory. However, in principle it is remotely possible that a\n      // file called `index.js` could be a directory instead of a file.\n      resolved = this.joinAndStat(dirPath, \"index\");\n    }\n\n    if (resolved) {\n      if (packageJsonMap) {\n        resolved.packageJsonMap = packageJsonMap;\n      }\n\n      // If the package.json file that governs resolved.path has a\n      // \"browser\" field, include it in resolved.packageJsonMap so that\n      // the ImportScanner can register the appropriate browser aliases.\n      const pkgJsonInfo = this.findPkgJsonSubsetForPath(resolved.path);\n      if (pkgJsonInfo &&\n          isObject(pkgJsonInfo.pkg.browser)) {\n        if (! resolved.packageJsonMap) {\n          resolved.packageJsonMap = Object.create(null);\n        }\n        resolved.packageJsonMap![pkgJsonInfo.path] = pkgJsonInfo.pkg;\n      }\n\n      resolved.id = convertToPosixPath(\n        convertToOSPath(resolved.path),\n        true\n      );\n    }\n\n    return resolved;\n  }\n\n  public joinAndStat(...joinArgs: string[]) {\n    const joined: string = pathJoin(...joinArgs);\n    const path = pathNormalize(joined);\n    const exactStat = this.statOrNull(path);\n    const exactResult = exactStat && { path, stat: exactStat };\n\n    let result: Resolution = null;\n\n    if (exactResult && exactStat && exactStat.isFile()) {\n      result = exactResult;\n    } else {\n      // No point in trying alternate file extensions if the parent\n      // directory does not exist.\n      const parentDirStat = this.statOrNull(pathDirname(path));\n      if (parentDirStat &&\n          parentDirStat.isDirectory()) {\n        this.extensions.some(ext => {\n          const pathWithExt = path + ext;\n          const stat = this.statOrNull(pathWithExt);\n          if (stat && ! stat.isDirectory()) {\n            return result = { path: pathWithExt, stat };\n          }\n        });\n      }\n    }\n\n    if (! result && exactResult && exactStat && exactStat.isDirectory()) {\n      // After trying all available file extensions, fall back to the\n      // original result if it was a directory.\n      result = exactResult;\n    }\n\n    return result;\n  }\n\n  private resolveAbsolute(id: string, _absParentPath: string): Resolution {\n    return id.charAt(0) === \"/\"\n      && this.joinAndStat(this.sourceRoot, id.slice(1))\n      || null;\n  }\n\n  private resolveRelative(id: string, absParentPath: string): Resolution {\n    if (id.charAt(0) === \".\") {\n      return this.joinAndStat(absParentPath, \"..\", id);\n    }\n    return null;\n  }\n\n  private resolveNodeModule(id: string, absParentPath: string): Resolution {\n    if (! Resolver.isTopLevel(id)) {\n      return null;\n    }\n\n    if (Resolver.isNative(id) &&\n        archMatches(this.targetArch, \"os\")) {\n      // Forbid installing any server module with the same name as a\n      // native Node module.\n      return null;\n    }\n\n    let sourceRoot: string | undefined;\n    const relParentPath = pathRelative(this.sourceRoot, absParentPath);\n    if (! relParentPath.startsWith(\"..\")) {\n      // If the file is contained by this.sourceRoot, then it's safe to\n      // use this.sourceRoot as the limiting ancestor directory in the\n      // while loop below, but we're still going to check whether the file\n      // resides in an external node_modules directory, since \"external\"\n      // .npm/package/node_modules directories are technically contained\n      // within the root directory of their packages.\n      sourceRoot = this.sourceRoot;\n    }\n\n    this.nodeModulesPaths.some(path => {\n      if (! pathRelative(path, absParentPath).startsWith(\"..\")) {\n        // If the file is inside an external node_modules directory,\n        // consider the rootDir to be the parent directory of that\n        // node_modules directory, rather than this.sourceRoot.\n        return sourceRoot = pathDirname(path);\n      }\n    });\n\n    let resolved = null;\n\n    if (sourceRoot) {\n      let dir = absParentPath; // It's ok for absParentPath to be a directory!\n      let dirStat = this.statOrNull(dir);\n      if (! (dirStat && dirStat.isDirectory())) {\n        dir = pathDirname(dir);\n      }\n\n      while (! (resolved = this.joinAndStat(dir, \"node_modules\", id))) {\n        if (dir === sourceRoot) {\n          break;\n        }\n\n        const parentDir = pathDirname(dir);\n        if (dir === parentDir) {\n          // We've reached the root of the file system??\n          break;\n        }\n\n        dir = parentDir;\n      }\n    }\n\n    if (! resolved) {\n      // After checking any local node_modules directories, fall back to\n      // the package NPM directory, if one was specified.\n      this.nodeModulesPaths.some(path => {\n        return resolved = this.joinAndStat(path, id);\n      });\n    }\n\n    // If the dependency is still not resolved, it might be handled by the\n    // fallback function defined in meteor/packages/modules-runtime/[modern|legacy|server].js, or\n    // it might be imported in code that will never run on this platform,\n    // so there is always the possibility that its absence is not actually\n    // a problem. As much as we might like to issue warnings about missing\n    // dependencies here, we just don't have enough information to make\n    // that determination until the code actually runs.\n\n    return resolved || \"missing\";\n  }\n\n  private getPkgJsonSubsetForDir(dirPath: string) {\n    const pkgJsonPath = pathJoin(dirPath, \"package.json\");\n    const pkg = optimisticReadJsonOrNull(pkgJsonPath);\n    if (! pkg) {\n      return null;\n    }\n\n    // Output a JS module that exports just the \"name\", \"version\", \"main\",\n    // and \"browser\" properties (if defined) from the package.json file.\n    const pkgSubset: Partial<typeof pkg> = {};\n\n    if (has(pkg, \"name\")) {\n      pkgSubset.name = pkg.name;\n    }\n\n    if (has(pkg, \"version\")) {\n      pkgSubset.version = pkg.version;\n    }\n\n    this.mainFields.forEach(name => {\n      const value = pkg[name];\n      if (isString(value) ||\n          isObject(value)) {\n        pkgSubset[name] = value;\n      }\n    });\n\n    return {\n      path: pkgJsonPath,\n      pkg: pkgSubset,\n    };\n  }\n\n  private findPkgJsonSubsetForPath(\n    path: string,\n  ): ReturnType<Resolver[\"getPkgJsonSubsetForDir\"]> {\n    const stat = this.statOrNull(path);\n\n    if (stat && stat.isDirectory()) {\n      const found = this.getPkgJsonSubsetForDir(path);\n      if (found) {\n        return found;\n      }\n\n      if (path === this.sourceRoot) {\n        return null;\n      }\n    }\n\n    const parentDir = pathDirname(path);\n\n    if (parentDir === path) {\n      return null;\n    }\n\n    if (pathBasename(parentDir) === \"node_modules\") {\n      return null;\n    }\n\n    return this.findPkgJsonSubsetForPath(parentDir);\n  }\n};\n\nimport { Profile } from \"../tool-env/profile\";\nconst Rp = Resolver.prototype as any;\nObject.keys(Rp).forEach(key => {\n  if (key === \"constructor\") return;\n  Rp[key] = Profile(`Resolver#${key}`, Rp[key]);\n});\n"],"sourceRoot":"","file":"tools/isobuild/resolver.js.map"}