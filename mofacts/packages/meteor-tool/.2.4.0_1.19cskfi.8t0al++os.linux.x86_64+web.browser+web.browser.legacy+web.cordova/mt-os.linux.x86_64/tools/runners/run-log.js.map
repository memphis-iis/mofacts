{"version":3,"sources":["/tools/runners/run-log.js"],"names":["Console","require","fiberHelpers","_Log","getLoggingPackage","loadIsopackage","Log","outputFormat","RunLog","self","rawLogs","messages","maxLength","consecutiveRestartMessages","consecutiveClientRestartMessages","temporaryMessageLength","Object","assign","prototype","_record","msg","push","length","shift","_clearSpecial","info","spaces","Array","join","process","stdout","write","CARRIAGE_RETURN","setRawLogs","logAppOutput","line","isStderr","obj","objFromText","level","stderr","parse","noYieldsAllowed","rawInfo","format","color","log","options","time","Date","message","arrow","logTemporary","logRestart","pop","logClientRestart","finish","clearLog","getLog","runLogInstance","forEach","method","exports","bind"],"mappings":"AAAA,IAAIA,OAAO,GAAGC,OAAO,CAAC,uBAAD,CAAP,CAAiCD,OAA/C;;AACA,IAAIE,YAAY,GAAGD,OAAO,CAAC,2BAAD,CAA1B,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIE,IAAJ;;AACA,SAASC,iBAAT,GAA6B;AAC3B,MAAI,CAAED,IAAN,EAAY;AACVA,IAAAA,IAAI,GAAGF,OAAO,CAAC,2BAAD,CAAP,CACJI,cADI,CACW,SADX,EAEJC,GAFH;AAGD,GAL0B,CAO3B;AACA;;;AACAH,EAAAA,IAAI,CAACI,YAAL,GAAoB,cAApB;AAEA,SAAOJ,IAAP;AACD;;AAED,IAAIK,MAAM,GAAG,YAAY;AACvB,MAAIC,IAAI,GAAG,IAAX;AAEAA,EAAAA,IAAI,CAACC,OAAL,GAAe,KAAf;AAEAD,EAAAA,IAAI,CAACE,QAAL,GAAgB,EAAhB,CALuB,CAKH;;AACpBF,EAAAA,IAAI,CAACG,SAAL,GAAiB,GAAjB,CANuB,CAQvB;AACA;AACA;;AACAH,EAAAA,IAAI,CAACI,0BAAL,GAAkC,IAAlC;AACAJ,EAAAA,IAAI,CAACK,gCAAL,GAAwC,IAAxC,CAZuB,CAcvB;AACA;AACA;;AACAL,EAAAA,IAAI,CAACM,sBAAL,GAA8B,IAA9B;AACD,CAlBD;;AAoBAC,MAAM,CAACC,MAAP,CAAcT,MAAM,CAACU,SAArB,EAAgC;AAC9BC,EAAAA,OAAO,EAAE,UAAUC,GAAV,EAAe;AACtB,QAAIX,IAAI,GAAG,IAAX;AAEAA,IAAAA,IAAI,CAACE,QAAL,CAAcU,IAAd,CAAmBD,GAAnB;;AACA,QAAIX,IAAI,CAACE,QAAL,CAAcW,MAAd,GAAuBb,IAAI,CAACG,SAAhC,EAA2C;AACzCH,MAAAA,IAAI,CAACE,QAAL,CAAcY,KAAd;AACD;AACF,GAR6B;AAU9BC,EAAAA,aAAa,EAAE,YAAY;AACzB,QAAIf,IAAI,GAAG,IAAX;;AAEA,QAAIA,IAAI,CAACI,0BAAT,EAAqC;AACnCJ,MAAAA,IAAI,CAACI,0BAAL,GAAkC,IAAlC;AACAb,MAAAA,OAAO,CAACyB,IAAR;AACD;;AAED,QAAIhB,IAAI,CAACK,gCAAT,EAA2C;AACzCL,MAAAA,IAAI,CAACK,gCAAL,GAAwC,IAAxC;AACAd,MAAAA,OAAO,CAACyB,IAAR;AACD;;AAED,QAAIhB,IAAI,CAACM,sBAAT,EAAiC;AAC/B,UAAIW,MAAM,GAAG,IAAIC,KAAJ,CAAUlB,IAAI,CAACM,sBAAL,GAA8B,CAAxC,EAA2Ca,IAA3C,CAAgD,GAAhD,CAAb;AACAC,MAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqBL,MAAM,GAAG1B,OAAO,CAACgC,eAAtC;AACAvB,MAAAA,IAAI,CAACM,sBAAL,GAA8B,IAA9B;AACD;AACF,GA5B6B;AA8B9BkB,EAAAA,UAAU,EAAE,UAAUvB,OAAV,EAAmB;AAC7B,SAAKA,OAAL,GAAe,CAAC,CAACA,OAAjB;AACD,GAhC6B;AAkC9BwB,EAAAA,YAAY,EAAE,UAAUC,IAAV,EAAgBC,QAAhB,EAA0B;AACtC,QAAI3B,IAAI,GAAG,IAAX;AAEA,QAAIH,GAAG,GAAGF,iBAAiB,EAA3B;AAEA,QAAIiC,GAAG,GAAID,QAAQ,GACR9B,GAAG,CAACgC,WAAJ,CAAgBH,IAAhB,EAAsB;AAAEI,MAAAA,KAAK,EAAE,MAAT;AAAiBC,MAAAA,MAAM,EAAE;AAAzB,KAAtB,CADQ,GAERlC,GAAG,CAACmC,KAAJ,CAAUN,IAAV,KAAmB7B,GAAG,CAACgC,WAAJ,CAAgBH,IAAhB,CAF9B;;AAGA1B,IAAAA,IAAI,CAACU,OAAL,CAAakB,GAAb;;AAEA5B,IAAAA,IAAI,CAACe,aAAL;;AACA,QAAIf,IAAI,CAACC,OAAT,EAAkB;AAChBV,MAAAA,OAAO,CAACoC,QAAQ,GAAG,UAAH,GAAgB,SAAzB,CAAP,CAA2CD,IAAI,GAAG,IAAlD;AACD,KAFD,MAEO;AACL;AACA,aAAOjC,YAAY,CAACwC,eAAb,CAA6B,YAAW;AAC7C1C,QAAAA,OAAO,CAAC2C,OAAR,CAAgBrC,GAAG,CAACsC,MAAJ,CAAWP,GAAX,EAAgB;AAAEQ,UAAAA,KAAK,EAAE;AAAT,SAAhB,IAAmC,IAAnD;AACD,OAFM,CAAP;AAGD;AACF,GArD6B;AAuD9B;AACA;AACA;AACA;AACAC,EAAAA,GAAG,EAAE,UAAU1B,GAAV,EAAe2B,OAAf,EAAwB;AAC3B,QAAItC,IAAI,GAAG,IAAX;AACAsC,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAIV,GAAG,GAAG;AACRW,MAAAA,IAAI,EAAE,IAAIC,IAAJ,EADE;AAERC,MAAAA,OAAO,EAAE9B,GAFD,CAGR;AACA;AACA;;AALQ,KAAV;;AAOAX,IAAAA,IAAI,CAACU,OAAL,CAAakB,GAAb;;AAEA5B,IAAAA,IAAI,CAACe,aAAL,GAZ2B,CAc3B;AACA;AACA;;;AACAxB,IAAAA,OAAO,CAAC+C,OAAO,CAACI,KAAR,GAAgB,WAAhB,GAA8B,MAA/B,CAAP,CAA8C/B,GAA9C;AACD,GA7E6B;AA+E9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAgC,EAAAA,YAAY,EAAE,UAAUhC,GAAV,EAAe;AAC3B,QAAIX,IAAI,GAAG,IAAX;;AAEAA,IAAAA,IAAI,CAACe,aAAL;;AACAK,IAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqBX,GAAG,GAAGpB,OAAO,CAACgC,eAAnC;AACAvB,IAAAA,IAAI,CAACM,sBAAL,GAA8BK,GAAG,CAACE,MAAlC;AACD,GA7F6B;AA+F9B+B,EAAAA,UAAU,EAAE,YAAY;AACtB,QAAI5C,IAAI,GAAG,IAAX;;AAEA,QAAIA,IAAI,CAACI,0BAAT,EAAqC;AACnC;AACA;AACAgB,MAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqB/B,OAAO,CAACgC,eAA7B;AACAvB,MAAAA,IAAI,CAACE,QAAL,CAAc2C,GAAd;AACA7C,MAAAA,IAAI,CAACI,0BAAL;AACD,KAND,MAMO;AACLJ,MAAAA,IAAI,CAACe,aAAL;;AACAf,MAAAA,IAAI,CAACI,0BAAL,GAAkC,CAAlC;AACD;;AAED,QAAIqC,OAAO,GAAG,4BAAd;;AACA,QAAIzC,IAAI,CAACI,0BAAL,GAAkC,CAAtC,EAAyC;AACvCqC,MAAAA,OAAO,IAAI,QAAQzC,IAAI,CAACI,0BAAb,GAA0C,GAArD;AACD,KAjBqB,CAkBtB;AACA;;;AACAgB,IAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqBmB,OAArB;;AAEAzC,IAAAA,IAAI,CAACU,OAAL,CAAa;AACX6B,MAAAA,IAAI,EAAE,IAAIC,IAAJ,EADK;AAEXC,MAAAA,OAAO,EAAEA;AAFE,KAAb;AAID,GAzH6B;AA2H9BK,EAAAA,gBAAgB,EAAE,YAAY;AAC5B,QAAI9C,IAAI,GAAG,IAAX;;AAEA,QAAIA,IAAI,CAACK,gCAAT,EAA2C;AACzC;AACA;AACAe,MAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqB/B,OAAO,CAACgC,eAA7B;AACAvB,MAAAA,IAAI,CAACE,QAAL,CAAc2C,GAAd;AACA7C,MAAAA,IAAI,CAACK,gCAAL;AACD,KAND,MAMO;AACLL,MAAAA,IAAI,CAACe,aAAL;;AACAf,MAAAA,IAAI,CAACK,gCAAL,GAAwC,CAAxC;AACD;;AAED,QAAIoC,OAAO,GAAG,kCAAd;;AACA,QAAIzC,IAAI,CAACK,gCAAL,GAAwC,CAA5C,EAA+C;AAC7CoC,MAAAA,OAAO,IAAI,QAAQzC,IAAI,CAACK,gCAAb,GAAgD,GAA3D;AACD,KAjB2B,CAkB5B;AACA;;;AACAe,IAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqBmB,OAArB;;AAEAzC,IAAAA,IAAI,CAACU,OAAL,CAAa;AACX6B,MAAAA,IAAI,EAAE,IAAIC,IAAJ,EADK;AAEXC,MAAAA,OAAO,EAAEA;AAFE,KAAb;AAID,GArJ6B;AAuJ9BM,EAAAA,MAAM,EAAE,YAAY;AAClB,QAAI/C,IAAI,GAAG,IAAX;;AAEAA,IAAAA,IAAI,CAACe,aAAL;AACD,GA3J6B;AA6J9BiC,EAAAA,QAAQ,EAAE,YAAY;AACpB,QAAIhD,IAAI,GAAG,IAAX;AACAA,IAAAA,IAAI,CAACE,QAAL,GAAgB,EAAhB;AACD,GAhK6B;AAkK9B+C,EAAAA,MAAM,EAAE,YAAY;AAClB,QAAIjD,IAAI,GAAG,IAAX;AACA,WAAOA,IAAI,CAACE,QAAZ;AACD;AArK6B,CAAhC,E,CAwKA;AACA;;AACA,IAAIgD,cAAc,GAAG,IAAInD,MAAJ,EAArB;AACA,CAAC,KAAD,EAAQ,cAAR,EAAwB,YAAxB,EAAsC,kBAAtC,EAA0D,cAA1D,EACE,YADF,EACgB,QADhB,EAC0B,UAD1B,EACsC,QADtC,EACgDoD,OADhD,CAEE,UAAUC,MAAV,EAAkB;AAChBC,EAAAA,OAAO,CAACD,MAAD,CAAP,GAAkBF,cAAc,CAACE,MAAD,CAAd,CAAuBE,IAAvB,CAA4BJ,cAA5B,CAAlB;AACD,CAJH","sourcesContent":["var Console = require('../console/console.js').Console;\nvar fiberHelpers = require('../utils/fiber-helpers.js');\n\n// runLog is primarily used by the parts of the tool which run apps locally. It\n// writes to standard output (and standard error, if rawLogs is set), and allows\n// special output forms like \"write this line, but let the next line overwrite\n// it\". It also makes its output available to the proxy, to be displayed to web\n// browsers if the app fails to run.\n//\n// It's not the only mechanism used for gathering messages! buildmessage is a\n// more structured way of gathering messages, but unlike log, it does not print\n// messages immediately.\n//\n// Some other parts of the code (eg commands and warehouse) write directly to\n// process.std{out,err} or to console.log; we should be careful to not do that\n// anywhere that may overlap with use of runLog.\n\nlet _Log;\nfunction getLoggingPackage() {\n  if (! _Log) {\n    _Log = require(\"../tool-env/isopackets.js\")\n      .loadIsopackage('logging')\n      .Log;\n  }\n\n  // Since no other process will be listening to stdout and parsing it,\n  // print directly in the same format as log messages from other apps\n  _Log.outputFormat = 'colored-text';\n\n  return _Log;\n}\n\nvar RunLog = function () {\n  var self = this;\n\n  self.rawLogs = false;\n\n  self.messages = []; // list of log objects\n  self.maxLength = 100;\n\n  // If non-null, the last thing logged was \"server restarted\"\n  // message, and the value will be the number of consecutive such\n  // messages that have been logged with no other intervening messages\n  self.consecutiveRestartMessages = null;\n  self.consecutiveClientRestartMessages = null;\n\n  // If non-null, the last thing that was logged was a temporary\n  // message (with a carriage return but no newline), and this is its\n  // length.\n  self.temporaryMessageLength = null;\n};\n\nObject.assign(RunLog.prototype, {\n  _record: function (msg) {\n    var self = this;\n\n    self.messages.push(msg);\n    if (self.messages.length > self.maxLength) {\n      self.messages.shift();\n    }\n  },\n\n  _clearSpecial: function () {\n    var self = this;\n\n    if (self.consecutiveRestartMessages) {\n      self.consecutiveRestartMessages = null;\n      Console.info();\n    }\n\n    if (self.consecutiveClientRestartMessages) {\n      self.consecutiveClientRestartMessages = null;\n      Console.info();\n    }\n\n    if (self.temporaryMessageLength) {\n      var spaces = new Array(self.temporaryMessageLength + 1).join(' ');\n      process.stdout.write(spaces + Console.CARRIAGE_RETURN);\n      self.temporaryMessageLength = null;\n    }\n  },\n\n  setRawLogs: function (rawLogs) {\n    this.rawLogs = !!rawLogs;\n  },\n\n  logAppOutput: function (line, isStderr) {\n    var self = this;\n\n    var Log = getLoggingPackage();\n\n    var obj = (isStderr ?\n               Log.objFromText(line, { level: 'warn', stderr: true }) :\n               Log.parse(line) || Log.objFromText(line));\n    self._record(obj);\n\n    self._clearSpecial();\n    if (self.rawLogs) {\n      Console[isStderr ? \"rawError\" : \"rawInfo\"](line + \"\\n\");\n    } else {\n      // XXX deal with test server logging differently?!\n      return fiberHelpers.noYieldsAllowed(function() {\n        Console.rawInfo(Log.format(obj, { color: true }) + \"\\n\");\n      });\n    }\n  },\n\n  // Log the message.\n  //  msg: message\n  //  options:\n  //    - arrow: if true, preface with => and wrap accordingly.\n  log: function (msg, options) {\n    var self = this;\n    options = options || {};\n    var obj = {\n      time: new Date,\n      message: msg\n      // in the future, might want to add something else to\n      // distinguish messages from runner from message from the app,\n      // but for now, nothing would use it, so we'll keep it simple\n    };\n    self._record(obj);\n\n    self._clearSpecial();\n\n    // Process the options. By default, we want to wordwrap the message with\n    // Console.info. If we ask for raw output, then we don't want to do that. If\n    // we ask for an arrow, we want to wrap around with => as the bulletPoint.\n    Console[options.arrow ? 'arrowInfo' : 'info'](msg);\n  },\n\n  // Write a message to the terminal that will get overwritten by the\n  // next message logged. (Don't put it in the log that getLog\n  // returns.)\n  // XXX Maybe this should return an object that you have to pass to the\n  //     subsequent log call, and only such a log call will overwrite it (and an\n  //     intervening log call will cause this to stay on the screen)?\n  //     eg, a log call from the updater can interweave with the logTemporary\n  //     calls in run-all.js\n  logTemporary: function (msg) {\n    var self = this;\n\n    self._clearSpecial();\n    process.stdout.write(msg + Console.CARRIAGE_RETURN);\n    self.temporaryMessageLength = msg.length;\n  },\n\n  logRestart: function () {\n    var self = this;\n\n    if (self.consecutiveRestartMessages) {\n      // replace old message in place. this assumes that the new restart message\n      // is not shorter than the old one.\n      process.stdout.write(Console.CARRIAGE_RETURN);\n      self.messages.pop();\n      self.consecutiveRestartMessages ++;\n    } else {\n      self._clearSpecial();\n      self.consecutiveRestartMessages = 1;\n    }\n\n    var message = \"=> Meteor server restarted\";\n    if (self.consecutiveRestartMessages > 1) {\n      message += \" (x\" + self.consecutiveRestartMessages + \")\";\n    }\n    // no newline, so that we can overwrite it if we get another\n    // restart message right after this one\n    process.stdout.write(message);\n\n    self._record({\n      time: new Date,\n      message: message\n    });\n  },\n\n  logClientRestart: function () {\n    var self = this;\n\n    if (self.consecutiveClientRestartMessages) {\n      // replace old message in place. this assumes that the new restart message\n      // is not shorter than the old one.\n      process.stdout.write(Console.CARRIAGE_RETURN);\n      self.messages.pop();\n      self.consecutiveClientRestartMessages ++;\n    } else {\n      self._clearSpecial();\n      self.consecutiveClientRestartMessages = 1;\n    }\n\n    var message = \"=> Client modified -- refreshing\";\n    if (self.consecutiveClientRestartMessages > 1) {\n      message += \" (x\" + self.consecutiveClientRestartMessages + \")\";\n    }\n    // no newline, so that we can overwrite it if we get another\n    // restart message right after this one\n    process.stdout.write(message);\n\n    self._record({\n      time: new Date,\n      message: message\n    });\n  },\n\n  finish: function () {\n    var self = this;\n\n    self._clearSpecial();\n  },\n\n  clearLog: function () {\n    var self = this;\n    self.messages = [];\n  },\n\n  getLog: function () {\n    var self = this;\n    return self.messages;\n  }\n});\n\n// Create a singleton instance of RunLog. Expose its public methods on the\n// object you get with require('./run-log.js').\nvar runLogInstance = new RunLog;\n['log', 'logTemporary', 'logRestart', 'logClientRestart', 'logAppOutput',\n  'setRawLogs', 'finish', 'clearLog', 'getLog'].forEach(\n  function (method) {\n    exports[method] = runLogInstance[method].bind(runLogInstance);\n  });\n"],"file":"tools/runners/run-log.js.map"}