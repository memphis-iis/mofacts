{"version":3,"sources":["/tools/tool-testing/output-log.js"],"names":["module","export","default","OutputLog","TestFailure","link","v","markThrowingMethods","hasOwn","Object","prototype","hasOwnProperty","constructor","run","lines","buffers","write","channel","text","call","offset","b","length","m","match","substr","push","Error","end","keys","forEach","bare","forbid","pattern","failure","line","RegExp","indexOf","get"],"mappings":"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","sourcesContent":["// Maintains a line-by-line merged log of multiple output channels\n// (eg, stdout and stderr).\nimport TestFailure from './test-failure.js';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport default class OutputLog {\n  constructor(run) {\n    // each entry is an object withgit p keys 'channel', 'text', and if it is\n    // the last entry and there was no newline terminator, 'bare'\n    this.lines = [];\n\n    // map from a channel name to an object representing a partially\n    // read line of text on that channel. That object has keys 'text'\n    // (text read), 'offset' (cursor position, equal to text.length\n    // unless a '\\r' has been read).\n    this.buffers = {};\n\n    // a Run, exclusively for inclusion in exceptions\n    this.run = run;\n  }\n\n  write(channel, text) {\n    if (!hasOwn.call(this.buffers, 'channel')) {\n      this.buffers[channel] = { text: '', offset: 0 };\n    }\n    const b = this.buffers[channel];\n\n    while (text.length) {\n      const m = text.match(/^[^\\n\\r]+/);\n      if (m) {\n        // A run of non-control characters.\n        b.text = b.text.substr(0, b.offset) +\n          m[0] + b.text.substr(b.offset + m[0].length);\n        b.offset += m[0].length;\n        text = text.substr(m[0].length);\n        continue;\n      }\n\n      if (text[0] === '\\r') {\n        b.offset = 0;\n        text = text.substr(1);\n        continue;\n      }\n\n      if (text[0] === '\\n') {\n        this.lines.push({ channel, text: b.text });\n        b.text = '';\n        b.offset = 0;\n        text = text.substr(1);\n        continue;\n      }\n\n      throw new Error(\"conditions should have been exhaustive?\");\n    }\n  }\n\n  end() {\n    Object.keys(this.buffers).forEach((channel) => {\n      if (this.buffers[channel].text.length) {\n        this.lines.push({\n          channel,\n          text: this.buffers[channel].text,\n          bare: true,\n        });\n        this.buffers[channel] = { text: '', offset: 0};\n      }\n    });\n  }\n\n  forbid(pattern, channel) {\n    const failure = new TestFailure('forbidden-string-present', {\n      run: this.run,\n    });\n\n    this.lines.forEach((line) => {\n      if (channel && channel !== line.channel) {\n        return;\n      }\n\n      const match = (pattern instanceof RegExp) ?\n        (line.text.match(pattern)) : (line.text.indexOf(pattern) !== -1);\n      if (match) {\n        throw failure;\n      }\n    });\n  }\n\n  get() {\n    return this.lines;\n  }\n}\n\nimport { markThrowingMethods } from \"./test-utils.js\";\nmarkThrowingMethods(OutputLog.prototype);\n"],"file":"tools/tool-testing/output-log.js.map"}