{"version":3,"sources":["/tools/utils/parse-stack.js"],"names":["module","export","parse","markBottom","markTop","_","require","err","stack","frames","split","slice","filter","f","match","indexOfFiberSplit","indexOf","outsideFiber","parseStackFrames","insideFiber","context","__bottom_mark__","apply","arguments","__top_mark__","stop","ret","some","frame","m","push","func","file","line","undefined","column","startsWith","isEmpty","Error"],"mappings":"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","sourcesContent":["const _ = require('underscore');\n\n// Given an Error (eg, 'new Error'), return the stack associated with\n// that error as an array. More recently called functions appear first\n// and each element is an object with keys:\n// - file: filename as it appears in the stack\n// - line: 1-indexed line number in file, as a Number\n// - column: 1-indexed column in line, as a Number\n// - func: name of the function in the frame (maybe null)\n//\n// Accomplishes this by parsing the text representation of the stack\n// with regular expressions. Unlikely to work anywhere but v8.\n//\n// If a function on the stack has been marked with mark(), don't\n// return anything past that function. We call this the \"user portion\"\n// of the stack.\nexport function parse(err) {\n  const stack = err.stack;\n  if (typeof stack !== \"string\") {\n    return {};\n  }\n\n  // at least the first line is the exception\n  const frames = stack.split(\"\\n\").slice(1)\n    // longjohn adds lines of the form '---' (45 times) to separate\n    // the trace across async boundaries. It's not clear if we need to\n    // separate the trace in the same way we do for future boundaries below\n    // (it's not clear that that code is still useful either)\n    // so for now, we'll just remove such lines\n    .filter(f => ! f.match(/^\\-{45}$/));\n  \n  // \"    - - - - -\"\n  // This is something added when you throw an Error through a Future. The\n  // stack above the dashes is the stack of the 'wait' call; the stack below\n  // is the stack inside the fiber where the Error is originally\n  // constructed.\n  // XXX This code assumes that the stack trace can only be split once. It's not\n  // clear whether this can happen multiple times.\n  const indexOfFiberSplit = frames.indexOf('    - - - - -');\n\n  if (indexOfFiberSplit === -1) {\n    // This is a normal stack trace, not a split fiber stack trace\n    return {\n      outsideFiber: parseStackFrames(frames)\n    }\n  }\n\n  // If this is a split stack trace from a future, parse the frames above and\n  // below the split separately.\n  const outsideFiber = parseStackFrames(frames);\n  const insideFiber = parseStackFrames(frames.slice(indexOfFiberSplit + 1));\n\n  return {\n    insideFiber,\n    outsideFiber\n  };\n}\n\n// Decorator. Mark the point at which a stack trace returned by\n// parse() should stop: no frames earlier than this point will be\n// included in the parsed stack. Confusingly, in the argot of the\n// times, you'd say that frames \"higher up\" than this or \"above\" this\n// will not be returned, but you'd also say that those frames are \"at\n// the bottom of the stack\". Frames below the bottom are the outer\n// context of the framework running the user's code.\nexport function markBottom(f, context) {\n  /* eslint-disable camelcase */\n  return function __bottom_mark__() {\n    return f.apply(context || this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\n// Decorator. Mark the point at which a stack trace returned by\n// parse() should begin: no frames later than this point will be\n// included in the parsed stack. The opposite of markBottom().\n// Frames above the top are helper functions defined by the\n// framework and executed by user code whose internal behavior\n// should not be exposed.\nexport function markTop(f) {\n  /* eslint-disable camelcase */\n  return function __top_mark__() {\n    return f.apply(this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\nfunction parseStackFrames(frames) {\n  let stop = false;\n  let ret = [];\n  frames.some(frame => {\n    if (stop) {\n      return true;\n    }\n\n    let m;\n\n    /* eslint-disable max-len */\n    if (m = frame.match(/^\\s*at\\s*((new )?.+?)\\s*(\\[as\\s*([^\\]]*)\\]\\s*)?\\((.*?)(:(\\d+))?(:(\\d+))?\\)\\s*$/)) {\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n      // \"    at My.Function (/path/to/myfile.js:532:39)\"\n      // \"    at Array.forEach (native)\"\n      // \"    at new My.Class (file.js:1:2)\"\n      // \"    at [object Object].main.registerCommand.name [as func] (meteor/tools/commands.js:1225:19)\"\n      // \"    at __top_mark__ [as matchErr] (meteor/tools/parse-stack.js:82:14)\"\n      //\n      // In that last example, it is not at all clear to me what the\n      // 'as' stanza refers to, but it is in m[3] if you find a use for it.\n      if (m[1].match(/(?:^|\\.)__top_mark__$/)) {\n        // m[1] could be Object.__top_mark__ or something like that\n        // depending on where exactly you put the function returned by\n        // markTop\n        ret = [];\n        return;\n      }\n      if (m[1].match(/(?:^|\\.)__bottom_mark__$/)) {\n        return stop = true;\n      }\n      ret.push({\n        func: m[1],\n        file: m[5],\n        line: m[7] ? +m[7] : undefined,\n        column: m[9] ? +m[9] : undefined\n      });\n      return;\n    }\n    /* eslint-enable max-len */\n\n    if (m = frame.match(/^\\s*at\\s+(.+?)(:(\\d+))?(:(\\d+))?\\s*$/)) {\n      // \"    at /path/to/myfile.js:532:39\"\n      ret.push({\n        file: m[1],\n        line: m[3] ? +m[3] : undefined,\n        column: m[5] ? +m[5] : undefined\n      });\n      return;\n    }\n\n    if (m = frame.match(/^\\s*-\\s*-\\s*-\\s*-\\s*-\\s*$/)) {\n      // Stop parsing if we reach a stack split from a Future\n      return stop = true;\n    }\n\n    if (frame.startsWith(\" => awaited here:\")) {\n      // The meteor-promise library inserts \" => awaited here:\" lines to\n      // indicate async boundaries.\n      return stop = true;\n    }\n\n    if (_.isEmpty(ret)) {\n      // We haven't found any stack frames, so probably we have newlines in the\n      // error message. Just skip this line.\n      return;\n    }\n\n    throw new Error(\"Couldn't parse stack frame: '\" + frame + \"'\");\n  });\n\n  return ret;\n}\n"],"file":"tools/utils/parse-stack.js.map"}