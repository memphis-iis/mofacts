{"version":3,"sources":["tools/fs/safe-watcher.ts"],"names":[],"mappings":"AACA,MAAA,CAAO,MAAP,CAAS;AAAA,EAAA,gBAAe,EAAA,MAAA,gBAAf;AAAqC,EAAA,KAAA,EAAA,MAAA;AAArC,CAAT;AAA8C,IAAA,OAAA;AAAA,MAAA,CAAA,IAAA,CAAA,qBAAA,EAAA;AAAA,EAAA,OAAA,CAAA,CAAA,EAAA;AAAA,IAAA,OAAA,GAAA,CAAA;AAAA;;AAAA,CAAA,EAAA,CAAA;AAAA,IAAA,UAAA,EAAA,WAAA,EAAA,eAAA,EAAA,SAAA,EAAA,WAAA;AAAA,MAAA,CAAA,IAAA,CAAA,SAAA,EAAA;AAAA,EAAA,UAAA,CAAA,CAAA,EAAA;AAAA,IAAA,UAAA,GAAA,CAAA;AAAA,GAAA;;AAAA,EAAA,WAAA,CAAA,CAAA,EAAA;AAAA,IAAA,WAAA,GAAA,CAAA;AAAA,GAAA;;AAAA,EAAA,eAAA,CAAA,CAAA,EAAA;AAAA,IAAA,eAAA,GAAA,CAAA;AAAA,GAAA;;AAAA,EAAA,SAAA,CAAA,CAAA,EAAA;AAAA,IAAA,SAAA,GAAA,CAAA;AAAA,GAAA;;AAAA,EAAA,WAAA,CAAA,CAAA,EAAA;AAAA,IAAA,WAAA,GAAA,CAAA;AAAA;;AAAA,CAAA,EAAA,CAAA;;AAS9C,MAAM,YAAY,GAAG,OAAO,CAAC,aAAD,CAA5B,C,CAEA;AACA;;;AACA,IAAI,eAAe,GAAG,CAAE,IAAI,CAAC,KAAL,CACtB,OAAO,CAAC,GAAR,CAAY,0BAAZ,IAA0C,OADpB,CAAxB,C,CAIA;AACA;AACA;;AACA,IAAI,kBAAkB,GAAG,IAAzB;;AACA,IAAI,OAAO,CAAC,GAAR,CAAY,+BAAZ,IACA,CAAE,IAAI,CAAC,KAAL,CAAW,OAAO,CAAC,GAAR,CAAY,+BAAvB,CADN,EAC+D;AAC7D,EAAA,kBAAkB,GAAG,KAArB;AACD;;AAED,IAAI,wBAAwB,GAC1B,EAAE,OAAO,CAAC,GAAR,CAAY,gCAAZ,IAAgD,IAAlD,CADF;AAGA,IAAI,2BAA2B,GAC7B,EAAE,OAAO,CAAC,GAAR,CAAY,gCAAZ,IAAgD,GAAlD,CADF,C,CAGA;AACA;;AACA,MAAM,wBAAwB,GAAG,KAAjC;AAcA,MAAM,OAAO,GAAiC,MAAM,CAAC,MAAP,CAAc,IAAd,CAA9C,C,CAEA;AACA;AACA;;AACA,MAAM,YAAY,GAAG,IAAI,GAAJ,EAArB,C,CAEA;AACA;AACA;;AACA,MAAM,YAAY,GAAG,IAAI,GAAJ,EAArB;;AAEA,SAAS,WAAT,CAAqB,OAArB,EAAoC;AAClC;AACA;AACA;AACA;AACA,SAAO,kBAAkB,GACrB,YAAY,CAAC,GAAb,CAAiB,OAAjB,CADqB,GAErB,IAFJ;AAGD;;AAED,SAAS,cAAT,CAAwB,OAAxB,EAAyC,QAAzC,EAAgE;AAC9D,QAAM,KAAK,GAAG,OAAO,CAAC,OAAD,CAAP,KACZ,OAAO,CAAC,OAAD,CAAP,GAAmB,eAAe,CAAC,OAAD,CADtB,CAAd,CAD8D,CAI9D;AACA;AACA;;AACA,EAAA,KAAK,CAAC,OAAN,GAP8D,CAS9D;AACA;;AACA,EAAA,KAAK,CAAC,SAAN,CAAgB,GAAhB,CAAoB,QAApB;AAEA,SAAO,KAAP;AACD;;AAED,SAAS,eAAT,CAAyB,OAAzB,EAAwC;AACtC,QAAM,IAAI,GAAG,UAAU,CAAC,OAAD,CAAvB;;AACA,MAAI,IAAI,IAAI,IAAI,CAAC,GAAL,GAAW,CAAnB,IAAwB,YAAY,CAAC,GAAb,CAAiB,IAAI,CAAC,GAAtB,CAA5B,EAAwD;AACtD,UAAM,KAAK,GAAG,YAAY,CAAC,GAAb,CAAiB,IAAI,CAAC,GAAtB,CAAd;;AACA,QAAI,OAAO,CAAC,OAAD,CAAP,KAAqB,KAAzB,EAAgC;AAC9B,aAAO,KAAP;AACD;AACF;;AAED,WAAS,WAAT,GAAoB;AAClB,QAAI,OAAJ,EAAa;AACX,MAAA,OAAO,CAAC,KAAR;AACA,MAAA,OAAO,GAAG,IAAV;;AACA,UAAI,IAAI,IAAI,IAAI,CAAC,GAAL,GAAW,CAAvB,EAA0B;AACxB,QAAA,YAAY,CAAC,MAAb,CAAoB,IAAI,CAAC,GAAzB;AACD;AACF;AACF;;AAED,MAAI,oBAAoB,GAAG,IAAI,CAAC,GAAL,EAA3B;AACA,QAAM,SAAS,GAAG,IAAI,GAAJ,EAAlB;AACA,MAAI,mBAAmB,GAAyC,IAAhE;AACA,MAAI,OAAO,GAAqB,IAAhC,CAtBsC,CAwBtC;AACA;;AACA,WAAS,kBAAT,GAA2B;AACzB,QAAI,WAAW,CAAC,OAAD,CAAf,EAA0B;AACxB;AACA;AACA;AACA;AACA,aAAO,2BAAP;AACD;;AAED,QAAI,eAAe,IAAI,kBAAvB,EAA2C;AACzC;AACA;AACA;AACA;AACA,aAAO,wBAAP;AACD,KAfwB,CAiBzB;AACA;AACA;AACA;AACA;;;AACA,WAAO,2BAAP;AACD;;AAED,WAAS,IAAT,CAAc,KAAd,EAA2B;AACzB,QAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACA;AACA;AACA;AACA;AACA,MAAA,WAAW,GANW,CAQtB;AACA;AACA;;AACA,MAAA,oBAAoB,GAAG,CAAvB;AAED,KAbD,MAaO;AACL,MAAA,YAAY,CAAC,GAAb,CAAiB,OAAjB;AACA,MAAA,OAAO;AACR;;AAED,IAAA,SAAS,CAAC,OAAV,CAAkB,EAAE,IAAI,EAAE,CAAC,KAAD,CAA1B;AACD;;AAED,WAAS,YAAT,CAAsB,KAAtB,EAAmC;AACjC,IAAA,oBAAoB,GAAG,IAAI,CAAC,GAAL,EAAvB;AACA,IAAA,IAAI,CAAC,KAAD,CAAJ,CAFiC,CAIjC;AACA;AACA;AACA;AACA;AACA;AACD;;AAED,WAAS,OAAT,GAAgB;AACd,QAAI,WAAW,CAAC,OAAD,CAAf,EAA0B;AACxB,UAAI,OAAJ,EAAa;AACX;AACA;AACD;;AACD,MAAA,OAAO,GAAG,iBAAiB,CAAC,OAAD,EAAU,YAAV,CAA3B;AACD,KAND,MAMO,IAAI,OAAJ,EAAa;AAClB,MAAA,WAAW;AACZ,KATa,CAWd;AACA;AACA;;;AACA,IAAA,oBAAoB,GAAG,CAAvB,CAdc,CAgBd;AACA;AACA;AACA;AACA;;AACA,IAAA,SAAS,CAAC,OAAD,EAAU,kBAAkB,EAA5B,EAAgC,gBAAhC,CAAT;AACD;;AAED,WAAS,gBAAT,CAA0B,OAA1B,EAA0C,OAA1C,EAAwD;AACtD,QAAI,OAAO,CAAC,GAAR,KAAgB,CAAhB,IACA,OAAO,CAAC,GAAR,KAAgB,CADhB,IAEA,CAAC,OAAO,CAAC,KAAT,KAAmB,CAAC,OAAO,CAAC,KAFhC,EAEuC;AACrC;AACA;AACA;AACD,KAPqD,CAStD;AACA;;;AACA,QAAI,IAAI,CAAC,GAAL,KAAa,oBAAb,GAAoC,kBAAkB,EAA1D,EAA8D;AAC5D,MAAA,IAAI,CAAC,QAAD,CAAJ;AACD;AACF;;AAED,QAAM,KAAK,GAAG;AACZ,IAAA,SADY;AAEZ,IAAA,OAFY;;AAIZ,IAAA,OAAO,CAAC,QAAD,EAAwB;AAC7B,UAAI,CAAE,OAAO,CAAC,OAAD,CAAb,EAAwB;AACtB;AACD;;AAED,MAAA,SAAS,CAAC,MAAV,CAAiB,QAAjB;;AACA,UAAI,SAAS,CAAC,IAAV,GAAiB,CAArB,EAAwB;AACtB;AACD,OAR4B,CAU7B;AACA;;;AACA,UAAI,mBAAJ,EAAyB;AACvB,QAAA,YAAY,CAAC,mBAAD,CAAZ;AACD;;AAED,MAAA,mBAAmB,GAAG,UAAU,CAAC,MAAK;AACpC,YAAI,SAAS,CAAC,IAAV,GAAiB,CAArB,EAAwB;AACtB;AACA;AACA;AACD;;AACD,QAAA,KAAK,CAAC,KAAN;AACD,OAP+B,EAO7B,wBAP6B,CAAhC;AAQD,KA5BW;;AA8BZ,IAAA,KAAK,GAAA;AACH,UAAI,OAAO,CAAC,OAAD,CAAP,KAAqB,KAAzB,EAAgC;AAChC,MAAA,OAAO,CAAC,OAAD,CAAP,GAAmB,IAAnB;;AAEA,UAAI,mBAAJ,EAAyB;AACvB,QAAA,YAAY,CAAC,mBAAD,CAAZ;AACA,QAAA,mBAAmB,GAAG,IAAtB;AACD;;AAED,MAAA,WAAW;AAEX,MAAA,WAAW,CAAC,OAAD,EAAU,gBAAV,CAAX;AACD;;AA1CW,GAAd;;AA6CA,MAAI,IAAI,IAAI,IAAI,CAAC,GAAL,GAAW,CAAvB,EAA0B;AACxB,IAAA,YAAY,CAAC,GAAb,CAAiB,IAAI,CAAC,GAAtB,EAA2B,KAA3B;AACD;;AAED,SAAO,KAAP;AACD;;AAEK,SAAU,gBAAV,GAA0B;AAC9B,EAAA,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,OAArB,CAA6B,OAAO,IAAG;AACrC,UAAM,KAAK,GAAG,OAAO,CAAC,OAAD,CAArB;;AACA,QAAI,KAAJ,EAAW;AACT,MAAA,KAAK,CAAC,KAAN;AACD;AACF,GALD;AAMD;;AAED,MAAM,YAAY,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAArB;;AAEA,SAAS,SAAT,CACE,OADF,EAEE,QAFF,EAGE,QAHF,EAGqD;AAEnD,QAAM,UAAU,GAAG,YAAY,CAAC,OAAD,CAA/B;;AAEA,SAAO,UAAP,EAAmB;AACjB;AACA;AACA,UAAM,WAAW,GAAG,UAAU,CAAC,IAAX,CAAgB,aAAhB,CAA8B,QAA9B,CAApB,CAHiB,CAKjB;AACA;;AACA,IAAA,UAAU,CAAC,IAAX,CAAgB,cAAhB,CAA+B,QAA/B,EAAyC,QAAzC,EAPiB,CASjB;AACA;;AACA,QAAI,UAAU,CAAC,IAAX,CAAgB,aAAhB,CAA8B,QAA9B,MAA4C,WAAhD,EAA6D;AAC3D;AACD;AACF,GAlBkD,CAoBnD;AACA;AACA;AACA;;;AACA,QAAM,OAAO,GAAG,SAAS,CAAC,OAAD,EAAU;AACjC,IAAA,UAAU,EAAE,KADqB;AAEjC,IAAA;AAFiC,GAAV,EAGtB,QAHsB,CAAzB;;AAKA,MAAI,CAAE,UAAN,EAAkB;AAChB,UAAM,UAAU,GAAG;AACjB,MAAA,IAAI,EAAE,OADW;AAEjB,MAAA;AAFiB,KAAnB;AAKA,IAAA,OAAO,CAAC,EAAR,CAAW,MAAX,EAAmB,MAAK;AACtB,UAAI,YAAY,CAAC,OAAD,CAAZ,KAA0B,UAA9B,EAA0C;AACxC,eAAO,YAAY,CAAC,OAAD,CAAnB;AACD;AACF,KAJD;AAMA,WAAO,YAAY,CAAC,OAAD,CAAZ,GAAwB,UAA/B;AACD,GA1CkD,CA4CnD;;;AACA,EAAA,UAAU,CAAC,IAAX,GAAkB,OAAlB,CA7CmD,CA+CnD;AACA;;AACA,MAAI,UAAU,CAAC,QAAX,KAAwB,QAA5B,EAAsC;AACpC,IAAA,UAAU,CAAC,IAAX,CAAgB,IAAhB;AACA,IAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB,CACE,eAAe,CAAC,WAAW,CAAC,OAAD,CAAZ,CADjB,EAEE,KAFF,EAES;AACP,IAAA,UAAU,CAAC,QAAX,GAAsB,QAHxB;AAKD;;AAED,SAAO,UAAP;AACD;;AAED,SAAS,iBAAT,CAA2B,OAA3B,EAA4C,QAA5C,EAAmE;AACjE,MAAI,eAAJ,EAAqB;AACnB,QAAI;AACF,aAAO,YAAY,CAAC,KAAb,CAAmB,eAAe,CAAC,OAAD,CAAlC,EAA6C,QAA7C,CAAP;AACD,KAFD,CAEE,OAAO,CAAP,EAAU;AACV,MAAA,6BAA6B,CAAC,CAAD,CAA7B,CADU,CAEV;AACA;AACD;AACF;;AAED,SAAO,IAAP;AACD;;AAED,IAAI,0BAA0B,GAAG,KAAjC,C,CAEA;AACA;;AACA,SAAe,6BAAf,CAA6C,KAA7C;AAAA,kCAA6E;AAC3E,QAAI,SAAS,GAAG,OAAO,CAAC,WAAD,CAAvB;;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,mBAAD,CAAtB;;AACA,QAAI,CAAE,0BAAF,IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,KAAK,CAAC,KAAN,KAAgB,SAAS,CAAC,MAT1B,IAUA;AACA,IAAA,QAAQ,CAAC,OAAT,CAAiB,QAAQ,CAAC,IAAT,EAAjB,EAAkC,UAAlC,CAXJ,EAWmD;AAEjD;AACA;AACA,UAAI,0BAAJ,EAAgC;AAChC,MAAA,0BAA0B,GAAG,IAA7B;;AAEA,UAAI,OAAO,GAAG,OAAO,CAAC,uBAAD,CAAP,CAAiC,OAA/C;;AACA,UAAI,CAAE,OAAO,CAAC,UAAR,EAAN,EAA4B;AAC1B,QAAA,OAAO,CAAC,SAAR,CACE,sEACE,kEADF,GAEE,qBAFF,GAGE,OAAO,CAAC,GAAR,CAAY,wFAAZ,CAJJ;AAKD;AACF;AACF,GA9BD;AAAA;;AAgCO,MAAM,KAAK,GAAG,OAAO,CAC1B,mBAD0B,EAE1B,CAAC,OAAD,EAAkB,QAAlB,KAA6C;AAC3C,QAAM,KAAK,GAAG,cAAc,CAAC,OAAD,EAAU,QAAV,CAA5B;AACA,SAAO;AACL,IAAA,KAAK,GAAA;AACH,MAAA,KAAK,CAAC,OAAN,CAAc,QAAd;AACD;;AAHI,GAAP;AAKD,CATyB,CAArB","sourcesContent":["import { FSWatcher, Stats } from \"fs\";\nimport { Profile } from \"../tool-env/profile\";\nimport {\n  statOrNull,\n  pathResolve,\n  convertToOSPath,\n  watchFile,\n  unwatchFile,\n} from \"./files\";\n\nconst watchLibrary = require(\"pathwatcher\");\n\n// Set METEOR_WATCH_FORCE_POLLING environment variable to a truthy value to\n// force the use of files.watchFile instead of watchLibrary.watch.\nvar WATCHER_ENABLED = ! JSON.parse(\n  process.env.METEOR_WATCH_FORCE_POLLING || \"false\"\n);\n\n// Default to prioritizing changed files, but disable that behavior (and\n// thus prioritize all files equally) if METEOR_WATCH_PRIORITIZE_CHANGED\n// is explicitly set to a string that parses to a falsy value.\nvar PRIORITIZE_CHANGED = true;\nif (process.env.METEOR_WATCH_PRIORITIZE_CHANGED &&\n    ! JSON.parse(process.env.METEOR_WATCH_PRIORITIZE_CHANGED)) {\n  PRIORITIZE_CHANGED = false;\n}\n\nvar DEFAULT_POLLING_INTERVAL =\n  +(process.env.METEOR_WATCH_POLLING_INTERVAL_MS || 5000);\n\nvar NO_WATCHER_POLLING_INTERVAL =\n  +(process.env.METEOR_WATCH_POLLING_INTERVAL_MS || 500);\n\n// This may seems like a long time to wait before actually closing the\n// file watchers, but it's to our advantage if they survive restarts.\nconst WATCHER_CLEANUP_DELAY_MS = 30000;\n\nexport type SafeWatcher = {\n  close: () => void;\n}\n\ntype EntryCallback = (event: string) => void;\n\ninterface Entry extends SafeWatcher {\n  callbacks: Set<EntryCallback>;\n  rewatch: () => void;\n  release: (callback: EntryCallback) => void;\n}\n\nconst entries: Record<string, Entry | null> = Object.create(null);\n\n// Pathwatcher complains (using console.error, ugh) if you try to watch\n// two files with the same stat.ino number but different paths, so we have\n// to deduplicate files by ino.\nconst entriesByIno = new Map;\n\n// Set of paths for which a change event has been fired, watched with\n// watchLibrary.watch if available. This could be an LRU cache, but in\n// practice it should never grow large enough for that to matter.\nconst changedPaths = new Set;\n\nfunction hasPriority(absPath: string) {\n  // If we're not prioritizing changed files, then all files have\n  // priority, which means they should be watched with native file\n  // watchers if the platform supports them. If we are prioritizing\n  // changed files, then only changed files get priority.\n  return PRIORITIZE_CHANGED\n    ? changedPaths.has(absPath)\n    : true;\n}\n\nfunction acquireWatcher(absPath: string, callback: EntryCallback) {\n  const entry = entries[absPath] || (\n    entries[absPath] = startNewWatcher(absPath));\n\n  // Watches successfully established in the past may have become invalid\n  // because the watched file was deleted or renamed, so we need to make\n  // sure we're still watching every time we call safeWatcher.watch.\n  entry.rewatch();\n\n  // The size of the entry.callbacks Set also serves as a reference count\n  // for this watcher.\n  entry.callbacks.add(callback);\n\n  return entry;\n}\n\nfunction startNewWatcher(absPath: string): Entry {\n  const stat = statOrNull(absPath);\n  if (stat && stat.ino > 0 && entriesByIno.has(stat.ino)) {\n    const entry = entriesByIno.get(stat.ino);\n    if (entries[absPath] === entry) {\n      return entry;\n    }\n  }\n\n  function safeUnwatch() {\n    if (watcher) {\n      watcher.close();\n      watcher = null;\n      if (stat && stat.ino > 0) {\n        entriesByIno.delete(stat.ino);\n      }\n    }\n  }\n\n  let lastWatcherEventTime = Date.now();\n  const callbacks = new Set<EntryCallback>();\n  let watcherCleanupTimer: ReturnType<typeof setTimeout> | null = null;\n  let watcher: FSWatcher | null = null;\n\n  // Determines the polling interval to be used for the fs.watchFile-based\n  // safety net that works on all platforms and file systems.\n  function getPollingInterval() {\n    if (hasPriority(absPath)) {\n      // Regardless of whether we have a native file watcher and it works\n      // correctly on this file system, poll prioritized files (that is,\n      // files that have been changed at least once) at a higher frequency\n      // (every 500ms by default).\n      return NO_WATCHER_POLLING_INTERVAL;\n    }\n\n    if (WATCHER_ENABLED || PRIORITIZE_CHANGED) {\n      // As long as native file watching is enabled (even if it doesn't\n      // work correctly) and the developer hasn't explicitly opted out of\n      // the file watching priority system, poll unchanged files at a\n      // lower frequency (every 5000ms by default).\n      return DEFAULT_POLLING_INTERVAL;\n    }\n\n    // If native file watching is disabled and the developer has\n    // explicitly opted out of the priority system, poll everything at the\n    // higher frequency (every 500ms by default). Note that this leads to\n    // higher idle CPU usage, so the developer may want to adjust the\n    // METEOR_WATCH_POLLING_INTERVAL_MS environment variable.\n    return NO_WATCHER_POLLING_INTERVAL;\n  }\n\n  function fire(event: string) {\n    if (event !== \"change\") {\n      // When we receive a \"delete\" or \"rename\" event, the watcher is\n      // probably not going to generate any more notifications for this\n      // file, so we close and nullify the watcher to ensure that\n      // entry.rewatch() will attempt to reestablish the watcher the next\n      // time we call safeWatcher.watch.\n      safeUnwatch();\n\n      // Make sure we don't throttle the watchFile callback after a\n      // \"delete\" or \"rename\" event, since it is now our only reliable\n      // source of file change notifications.\n      lastWatcherEventTime = 0;\n\n    } else {\n      changedPaths.add(absPath);\n      rewatch();\n    }\n\n    callbacks.forEach(cb => cb(event));\n  }\n\n  function watchWrapper(event: string) {\n    lastWatcherEventTime = Date.now();\n    fire(event);\n\n    // It's tempting to call unwatchFile(absPath, watchFileWrapper) here,\n    // but previous watcher success is no guarantee of future watcher\n    // reliability. For example, watchLibrary.watch works just fine when file\n    // changes originate from within a Vagrant VM, but changes to shared\n    // files made outside the VM are invisible to watcher, so our only\n    // hope of catching them is to continue polling.\n  }\n\n  function rewatch() {\n    if (hasPriority(absPath)) {\n      if (watcher) {\n        // Already watching; nothing to do.\n        return;\n      }\n      watcher = watchLibraryWatch(absPath, watchWrapper);\n    } else if (watcher) {\n      safeUnwatch();\n    }\n\n    // Since we're about to restart the stat-based file watcher, we don't\n    // want to miss any of its events because of the lastWatcherEventTime\n    // throttling that it attempts to do.\n    lastWatcherEventTime = 0;\n\n    // We use files.watchFile in addition to watcher.watch as a fail-safe\n    // to detect file changes even on network file systems.  However\n    // (unless the user disabled watcher or this watcher call failed), we\n    // use a relatively long default polling interval of 5000ms to save\n    // CPU cycles.\n    statWatch(absPath, getPollingInterval(), watchFileWrapper);\n  }\n\n  function watchFileWrapper(newStat: Stats, oldStat: Stats) {\n    if (newStat.ino === 0 &&\n        oldStat.ino === 0 &&\n        +newStat.mtime === +oldStat.mtime) {\n      // Node calls the watchFile listener once with bogus identical stat\n      // objects, which should not trigger a file change event.\n      return;\n    }\n\n    // If a watcher event fired in the last polling interval, ignore\n    // this event.\n    if (Date.now() - lastWatcherEventTime > getPollingInterval()) {\n      fire(\"change\");\n    }\n  }\n\n  const entry = {\n    callbacks,\n    rewatch,\n\n    release(callback: EntryCallback) {\n      if (! entries[absPath]) {\n        return;\n      }\n\n      callbacks.delete(callback);\n      if (callbacks.size > 0) {\n        return;\n      }\n\n      // Once there are no more callbacks in the Set, close both watchers\n      // and nullify the shared data.\n      if (watcherCleanupTimer) {\n        clearTimeout(watcherCleanupTimer);\n      }\n\n      watcherCleanupTimer = setTimeout(() => {\n        if (callbacks.size > 0) {\n          // If another callback was added while the timer was pending, we\n          // can avoid tearing anything down.\n          return;\n        }\n        entry.close();\n      }, WATCHER_CLEANUP_DELAY_MS);\n    },\n\n    close() {\n      if (entries[absPath] !== entry) return;\n      entries[absPath] = null;\n\n      if (watcherCleanupTimer) {\n        clearTimeout(watcherCleanupTimer);\n        watcherCleanupTimer = null;\n      }\n\n      safeUnwatch();\n\n      unwatchFile(absPath, watchFileWrapper);\n    }\n  };\n\n  if (stat && stat.ino > 0) {\n    entriesByIno.set(stat.ino, entry);\n  }\n\n  return entry;\n}\n\nexport function closeAllWatchers() {\n  Object.keys(entries).forEach(absPath => {\n    const entry = entries[absPath];\n    if (entry) {\n      entry.close();\n    }\n  });\n}\n\nconst statWatchers = Object.create(null);\n\nfunction statWatch(\n  absPath: string,\n  interval: number,\n  callback: (current: Stats, previous: Stats) => void,\n) {\n  const oldWatcher = statWatchers[absPath];\n\n  while (oldWatcher) {\n    // Make sure this callback no longer appears among the listeners for\n    // this StatWatcher.\n    const countBefore = oldWatcher.stat.listenerCount(\"change\");\n\n    // This removes at most one occurrence of the callback from the\n    // listeners list...\n    oldWatcher.stat.removeListener(\"change\", callback);\n\n    // ... so we have to keep calling it until the first time\n    // it removes nothing.\n    if (oldWatcher.stat.listenerCount(\"change\") === countBefore) {\n      break;\n    }\n  }\n\n  // This doesn't actually call newStat.start again if there's already a\n  // watcher for this file, so it won't change any interval previously\n  // specified. In the rare event that the interval needs to change, we\n  // manually stop and restart the StatWatcher below.\n  const newStat = watchFile(absPath, {\n    persistent: false, // never persistent\n    interval,\n  }, callback);\n\n  if (! oldWatcher) {\n    const newWatcher = {\n      stat: newStat,\n      interval,\n    };\n\n    newStat.on(\"stop\", () => {\n      if (statWatchers[absPath] === newWatcher) {\n        delete statWatchers[absPath];\n      }\n    });\n\n    return statWatchers[absPath] = newWatcher;\n  }\n\n  // These should be identical at this point, but just in case.\n  oldWatcher.stat = newStat;\n\n  // If the interval needs to be changed, manually stop and restart the\n  // StatWatcher using lower-level methods than unwatchFile and watchFile.\n  if (oldWatcher.interval !== interval) {\n    oldWatcher.stat.stop();\n    oldWatcher.stat.start(\n      convertToOSPath(pathResolve(absPath)),\n      false, // never persistent\n      oldWatcher.interval = interval,\n    );\n  }\n\n  return oldWatcher;\n}\n\nfunction watchLibraryWatch(absPath: string, callback: EntryCallback) {\n  if (WATCHER_ENABLED) {\n    try {\n      return watchLibrary.watch(convertToOSPath(absPath), callback);\n    } catch (e) {\n      maybeSuggestRaisingWatchLimit(e);\n      // ... ignore the error.  We'll still have watchFile, which is good\n      // enough.\n    }\n  }\n\n  return null;\n}\n\nlet suggestedRaisingWatchLimit = false;\n\n// This function is async so that archinfo.host() (which may call\n// utils.execFileSync) will run in a Fiber.\nasync function maybeSuggestRaisingWatchLimit(error: Error & { errno: number }) {\n  var constants = require('constants');\n  var archinfo = require('../utils/archinfo');\n  if (! suggestedRaisingWatchLimit &&\n      // Note: the not-super-documented require('constants') maps from\n      // strings to SYSTEM errno values. System errno values aren't the same\n      // as the numbers used internally by libuv! Once we're upgraded\n      // to Node 0.12, we'll have the system errno as a string (on 'code'),\n      // but the support for that wasn't in Node 0.10's uv.\n      // See our PR https://github.com/atom/node-pathwatcher/pull/53\n      // (and make sure to read the final commit message, not the original\n      // proposed PR, which had a slightly different interface).\n      error.errno === constants.ENOSPC &&\n      // The only suggestion we currently have is for Linux.\n      archinfo.matches(archinfo.host(), 'os.linux')) {\n\n    // Check suggestedRaisingWatchLimit again because archinfo.host() may\n    // have yielded.\n    if (suggestedRaisingWatchLimit) return;\n    suggestedRaisingWatchLimit = true;\n\n    var Console = require('../console/console.js').Console;\n    if (! Console.isHeadless()) {\n      Console.arrowWarn(\n        \"It looks like a simple tweak to your system's configuration will \" +\n          \"make many tools (including this Meteor command) more efficient. \" +\n          \"To learn more, see \" +\n          Console.url(\"https://github.com/meteor/docs/blob/master/long-form/file-change-watcher-efficiency.md\"));\n    }\n  }\n}\n\nexport const watch = Profile(\n  \"safeWatcher.watch\",\n  (absPath: string, callback: EntryCallback) => {\n    const entry = acquireWatcher(absPath, callback);\n    return {\n      close() {\n        entry.release(callback);\n      }\n    } as SafeWatcher;\n  }\n);\n"],"sourceRoot":"","file":"tools/fs/safe-watcher.js.map"}