{"version":3,"sources":["/tools/isobuild/js-analyze.js"],"names":["module1","export","findImportedModuleIdentifiers","findAssignedGlobals","parse","link","v","analyzeScope","analyze","LRU","default","Visitor","findPossibleIndexes","hasOwn","Object","prototype","hasOwnProperty","objToStr","toString","isRegExp","value","call","AST_CACHE","max","Math","pow","length","ast","loc","end","line","tryToParse","source","hash","has","get","e","$ParseError","set","possibleIndexes","importedIdentifierVisitor","visit","identifiers","reset","rootPath","code","requireIsBound","create","addIdentifier","id","type","dynamic","entry","possiblySpurious","visitFunctionExpression","path","_functionParamRequireHelper","visitFunctionDeclaration","visitArrowFunctionExpression","node","getValue","params","some","param","isIdWithName","visitChildren","visitCallExpression","args","arguments","argc","firstArg","isStringLiteral","callee","object","propertyName","isPropertyWithName","property","visitImportDeclaration","_importExportSourceHelper","visitExportAllDeclaration","visitExportNamedDeclaration","name","test","globalsCache","globals","sum","keys","forEach","scopeManager","ecmaVersion","sourceType","ignoreEval","nodejsScope","program","programScope","acquire","assignedGlobals","implicit","variables","variable","left","identifier","writeExpr"],"mappings":"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","sourcesContent":["import { parse } from 'meteor-babel';\nimport { analyze as analyzeScope } from 'escope';\nimport LRU from \"lru-cache\";\n\nimport Visitor from \"reify/lib/visitor.js\";\nimport { findPossibleIndexes } from \"reify/lib/utils.js\";\n\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst objToStr = Object.prototype.toString\n\nfunction isRegExp(value) {\n  return value && objToStr.call(value) === \"[object RegExp]\";\n}\n\nvar AST_CACHE = new LRU({\n  max: Math.pow(2, 12),\n  length(ast) {\n    return ast.loc.end.line;\n  }\n});\n\n// Like babel.parse, but annotates any thrown error with $ParseError = true.\nfunction tryToParse(source, hash) {\n  if (hash && AST_CACHE.has(hash)) {\n    return AST_CACHE.get(hash);\n  }\n\n  let ast;\n\n  try {\n    ast = parse(source);\n  } catch (e) {\n    if (typeof e.loc === 'object') {\n      e.$ParseError = true;\n    }\n    throw e;\n  }\n\n  if (hash) {\n    AST_CACHE.set(hash, ast);\n  }\n\n  return ast;\n}\n\n/**\n * The `findImportedModuleIdentifiers` function takes a string of module\n * source code and returns a map from imported module identifiers to AST\n * nodes. The keys of this map are used in ./import-scanner.ts to traverse\n * the module dependency graph. The AST nodes are generally ignored.\n *\n * The implementation uses a regular expression to scan quickly for\n * possible locations of certain tokens (`require`, `import`, `export`),\n * then uses that location information to steer the AST traversal, so that\n * it visits only subtrees that contain interesting tokens, saving a lot\n * of time by ignoring the rest of the AST. The AST traversal determines\n * if the tokens were actually what we thought they were (a `require`\n * function call, or an `import` or `export` statement).\n */\nexport function findImportedModuleIdentifiers(source, hash) {\n  const possibleIndexes = findPossibleIndexes(source, [\n    \"require\",\n    \"import\",\n    \"export\",\n    \"dynamicImport\",\n    \"link\",\n  ]);\n\n  if (possibleIndexes.length === 0) {\n    return {};\n  }\n\n  const ast = tryToParse(source, hash);\n  importedIdentifierVisitor.visit(ast, source, possibleIndexes);\n  return importedIdentifierVisitor.identifiers;\n}\n\nconst importedIdentifierVisitor = new (class extends Visitor {\n  reset(rootPath, code, possibleIndexes) {\n    this.requireIsBound = false;\n    this.identifiers = Object.create(null);\n\n    // Defining this.possibleIndexes causes the Visitor to ignore any\n    // subtrees of the AST that do not contain any indexes of identifiers\n    // that we care about. Note that findPossibleIndexes uses a RegExp to\n    // scan for the given identifiers, so there may be false positives,\n    // but that's fine because it just means scanning more of the AST.\n    this.possibleIndexes = possibleIndexes;\n  }\n\n  addIdentifier(id, type, dynamic) {\n    const entry = hasOwn.call(this.identifiers, id)\n      ? this.identifiers[id]\n      : this.identifiers[id] = {\n          possiblySpurious: true,\n          dynamic: !! dynamic\n        };\n\n    if (! dynamic) {\n      entry.dynamic = false;\n    }\n\n    if (type === \"require\") {\n      // If the identifier comes from a require call, but require is not a\n      // free variable, then this dependency might be spurious.\n      entry.possiblySpurious =\n        entry.possiblySpurious && this.requireIsBound;\n    } else {\n      // The import keyword can't be shadowed, so any dependencies\n      // registered by import statements should be trusted absolutely.\n      entry.possiblySpurious = false;\n    }\n  }\n\n  visitFunctionExpression(path) {\n    return this._functionParamRequireHelper(path);\n  }\n\n  visitFunctionDeclaration(path) {\n    return this._functionParamRequireHelper(path);\n  }\n\n  visitArrowFunctionExpression(path) {\n    return this._functionParamRequireHelper(path);\n  }\n\n  _functionParamRequireHelper(path) {\n    const node = path.getValue();\n    if (node.params.some(param => isIdWithName(param, \"require\"))) {\n      const { requireIsBound } = this;\n      this.requireIsBound = true;\n      this.visitChildren(path);\n      this.requireIsBound = requireIsBound;\n    } else {\n      this.visitChildren(path);\n    }\n  }\n\n  visitCallExpression(path) {\n    const node = path.getValue();\n    const args = node.arguments;\n    const argc = args.length;\n    const firstArg = args[0];\n\n    this.visitChildren(path);\n\n    if (! isStringLiteral(firstArg)) {\n      return;\n    }\n\n    if (isIdWithName(node.callee, \"require\")) {\n      this.addIdentifier(firstArg.value, \"require\");\n\n    } else if (node.callee.type === \"Import\" ||\n               isIdWithName(node.callee, \"import\")) {\n      this.addIdentifier(firstArg.value, \"import\", true);\n\n    } else if (node.callee.type === \"MemberExpression\" &&\n               // The Reify compiler sometimes renames references to the\n               // CommonJS module object for hygienic purposes, but it\n               // always does so by appending additional numbers.\n               isIdWithName(node.callee.object, /^module\\d*$/)) {\n      const propertyName =\n        isPropertyWithName(node.callee.property, \"link\") ||\n        isPropertyWithName(node.callee.property, \"dynamicImport\");\n\n      if (propertyName) {\n        this.addIdentifier(\n          firstArg.value,\n          \"import\",\n          propertyName === \"dynamicImport\"\n        );\n      }\n    }\n  }\n\n  visitImportDeclaration(path) {\n    return this._importExportSourceHelper(path);\n  }\n\n  visitExportAllDeclaration(path) {\n    return this._importExportSourceHelper(path);\n  }\n\n  visitExportNamedDeclaration(path) {\n    return this._importExportSourceHelper(path);\n  }\n\n  _importExportSourceHelper(path) {\n    const node = path.getValue();\n    // The .source of an ImportDeclaration or Export{Named,All}Declaration\n    // is always a string-valued Literal node, if not null.\n    if (isStringLiteral(node.source)) {\n      this.addIdentifier(\n        node.source.value,\n        \"import\",\n        false\n      );\n    }\n  }\n});\n\nfunction isIdWithName(node, name) {\n  if (! node ||\n      node.type !== \"Identifier\") {\n    return false;\n  }\n\n  if (typeof name === \"string\") {\n    return node.name === name;\n  }\n\n  if (isRegExp(name)) {\n    return name.test(node.name);\n  }\n\n  return false;\n}\n\nfunction isStringLiteral(node) {\n  return node && (\n    node.type === \"StringLiteral\" ||\n    (node.type === \"Literal\" &&\n     typeof node.value === \"string\"));\n}\n\nfunction isPropertyWithName(node, name) {\n  if (isIdWithName(node, name) ||\n      (isStringLiteral(node) &&\n       node.value === name)) {\n    return name;\n  }\n}\n\n// Analyze the JavaScript source code `source` and return a dictionary of all\n// globals which are assigned to in the package. The values in the dictionary\n// are all `true`.\n//\n// This is intended for use in detecting package-scope variables in Meteor\n// packages, where the linker needs to add a \"var\" statement to prevent them\n// from staying as globals.\n//\n// It only cares about assignments to variables; an assignment to a field on an\n// object (`Foo.Bar = true`) neither causes `Foo` nor `Foo.Bar` to be returned.\nconst globalsCache = new LRU({\n  max: Math.pow(2, 12),\n  length(globals) {\n    let sum = 0;\n    Object.keys(globals).forEach(name => sum += name.length);\n    return sum;\n  }\n});\n\nexport function findAssignedGlobals(source, hash) {\n  if (hash && globalsCache.has(hash)) {\n    return globalsCache.get(hash);\n  }\n\n  const ast = tryToParse(source, hash);\n\n  // We have to pass ignoreEval; otherwise, the existence of a direct eval call\n  // causes escope to not bother to resolve references in the eval's scope.\n  // This is because an eval can pull references inward:\n  //\n  //   function outer() {\n  //     var i = 42;\n  //     function inner() {\n  //       eval('var i = 0');\n  //       i;  // 0, not 42\n  //     }\n  //   }\n  //\n  // But it can't pull references outward, so for our purposes it is safe to\n  // ignore.\n  const scopeManager = analyzeScope(ast, {\n    ecmaVersion: 6,\n    sourceType: \"module\",\n    ignoreEval: true,\n    // Ensures we don't treat top-level var declarations as globals.\n    nodejsScope: true,\n  });\n\n  const program = ast.type === \"File\" ? ast.program : ast;\n  const programScope = scopeManager.acquire(program);\n  const assignedGlobals = {};\n\n  // Passing {sourceType: \"module\"} to analyzeScope leaves this list\n  // strangely empty, but {sourceType: \"script\"} forbids ImportDeclaration\n  // nodes (because they are only legal in modules.\n  programScope.implicit.variables.forEach(variable => {\n    assignedGlobals[variable.name] = true;\n  });\n\n  // Fortunately, even with {sourceType: \"module\"}, the .implicit.left\n  // array still has all the information we need, as long as we ignore\n  // global variable references that are not assignments.\n  programScope.implicit.left.forEach(entry => {\n    if (entry.identifier &&\n        entry.identifier.type === \"Identifier\" &&\n        // Only consider identifers that are assigned a value.\n        entry.writeExpr) {\n      assignedGlobals[entry.identifier.name] = true;\n    }\n  });\n\n  if (hash) {\n    globalsCache.set(hash, assignedGlobals);\n  }\n\n  return assignedGlobals;\n}\n"],"file":"tools/isobuild/js-analyze.js.map"}