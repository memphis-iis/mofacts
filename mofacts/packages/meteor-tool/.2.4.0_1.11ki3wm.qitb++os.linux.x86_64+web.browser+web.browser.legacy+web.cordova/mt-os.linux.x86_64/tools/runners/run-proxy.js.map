{"version":3,"sources":["/tools/runners/run-proxy.js"],"names":["Anser","require","runLog","Proxy","options","self","listenPort","listenHost","proxyToPort","proxyToHost","onFailure","ignoredUrls","mode","httpQueue","websocketQueue","proxy","server","Object","assign","prototype","start","Error","started","http","net","httpProxy","createProxyServer","agent","Agent","maxSockets","xfwd","createServer","req","res","includes","url","push","_tryHandleConnections","on","socket","head","allowStart","promise","Promise","resolve","err","code","port","log","syscall","resOrSocket","logMessage","ServerResponse","headersSent","writeHead","end","Socket","listen","close","await","stop","forEach","c","statusCode","destroy","attempt","fn","e","length","shift","showErrorPage","web","target","ws","setMode","write","getLog","item","ansiToHtml","escapeForHtml","message","exports"],"mappings":"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","sourcesContent":["var Anser = require(\"anser\");\nvar runLog = require('./run-log.js');\n\n// options: listenPort, proxyToPort, proxyToHost,\n// onFailure, ignoredUrls\nvar Proxy = function (options) {\n  var self = this;\n\n  self.listenPort = options.listenPort;\n  self.listenHost = options.listenHost;\n  // note: run-all.js updates proxyToPort directly\n  self.proxyToPort = options.proxyToPort;\n  self.proxyToHost = options.proxyToHost || '127.0.0.1';\n  self.onFailure = options.onFailure || function () {};\n  self.ignoredUrls = options.ignoredUrls || [];\n\n  self.mode = \"hold\";\n  self.httpQueue = []; // keys: req, res\n  self.websocketQueue = []; // keys: req, socket, head\n\n  self.proxy = null;\n  self.server = null;\n};\n\nObject.assign(Proxy.prototype, {\n  // Start the proxy server, block (yield) until it is ready to go\n  // (actively listening on outer and proxying to inner), and then\n  // return.\n  start: function () {\n    var self = this;\n\n    if (self.server) {\n      throw new Error(\"already running?\");\n    }\n\n    self.started = false;\n\n    var http = require('http');\n    var net = require('net');\n    var httpProxy = require('http-proxy');\n\n    self.proxy = httpProxy.createProxyServer({\n      // agent is required to handle keep-alive, and http-proxy 1.0 is a little\n      // buggy without it: https://github.com/nodejitsu/node-http-proxy/pull/488\n      agent: new http.Agent({ maxSockets: 100 }),\n      xfwd: true\n    });\n\n    var server = self.server = http.createServer(function (req, res) {\n      // Normal HTTP request\n      if (self.ignoredUrls.includes(req.url)) {\n        return;\n      }\n\n      self.httpQueue.push({ req: req, res: res });\n      self._tryHandleConnections();\n    });\n\n    self.server.on('upgrade', function (req, socket, head) {\n      if (self.ignoredUrls.includes(req.url)) {\n        return;\n      }\n\n      // Websocket connection\n      self.websocketQueue.push({ req: req, socket: socket, head: head });\n      self._tryHandleConnections();\n    });\n\n    var allowStart;\n    var promise = new Promise(function (resolve) {\n      allowStart = resolve;\n    });\n\n    self.server.on('error', function (err) {\n      if (err.code === 'EADDRINUSE') {\n        var port = self.listenPort;\n        runLog.log(\n\"Can't listen on port \" + port + \". Perhaps another Meteor is running?\\n\" +\n\"\\n\" +\n\"Running two copies of Meteor in the same application directory\\n\" +\n\"will not work. If something else is using port \" + port + \", you can\\n\" +\n\"specify an alternative port with --port <port>.\");\n      } else if (self.listenHost &&\n                 (err.code === 'ENOTFOUND' || err.code === 'EADDRNOTAVAIL')) {\n        // This handles the case of \"entered a DNS name that's unknown\"\n        // (ENOTFOUND from getaddrinfo) and \"entered some random IP that we\n        // can't bind to\" (EADDRNOTAVAIL from listen).\n        runLog.log(\n\"Can't listen on host \" + self.listenHost + \" (\" + err.code + \" from \" +\n            err.syscall + \").\");\n\n      } else {\n        runLog.log('' + err);\n      }\n      self.onFailure();\n      allowStart();\n    });\n\n    // Don't crash if the app doesn't respond. instead return an error\n    // immediately. This shouldn't happen much since we try to not\n    // send requests if the app is down.\n    //\n    // Currently, this error is emitted if the proxy->server connection has an\n    // error (whether in HTTP or websocket proxying).  It is not emitted if the\n    // client->proxy connection has an error, though this may change; see\n    // discussion at https://github.com/nodejitsu/node-http-proxy/pull/488\n    self.proxy.on('error', function (err, req, resOrSocket) {\n      if (err.code === 'HPE_HEADER_OVERFLOW') {\n        const logMessage = 'Error during proxy to server communication ' +\n          'due to the header size exceeding Node\\'s currently ' +\n          'configured limit. This limit is configurable with a command ' +\n          'line option (https://nodejs.org/api/cli.html#cli_max_http_header_size_size ' +\n          'and https://docs.meteor.com/commandline.html#meteorrun).';\n        runLog.log(logMessage);\n      }\n\n      if (resOrSocket instanceof http.ServerResponse) {\n        if (!resOrSocket.headersSent) {\n          // Return a 503, but only if we haven't already written headers (or\n          // we'll get an ugly crash about rendering headers twice).  end()\n          // doesn't crash if called twice so we don't have to conditionalize\n          // that call.\n          resOrSocket.writeHead(503, {\n            'Content-Type': 'text/plain'\n          });\n        }\n        resOrSocket.end('Unexpected error.');\n      } else if (resOrSocket instanceof net.Socket) {\n        resOrSocket.end();\n      }\n    });\n\n    self.server.listen(self.listenPort, self.listenHost || '0.0.0.0', function () {\n      if (self.server) {\n        self.started = true;\n      } else {\n        // stop() got called while we were invoking listen! Close the server (we\n        // still have the var server). The rest of the cleanup shouldn't be\n        // necessary.\n        server.close();\n      }\n      allowStart();\n    });\n\n    promise.await();\n  },\n\n  // Idempotent.\n  stop: function () {\n    var self = this;\n\n    if (! self.server) {\n      return;\n    }\n\n    if (! self.started) {\n      // This probably means that we failed to listen. However, there could be a\n      // race condition and we could be in the middle of starting to listen! In\n      // that case, the listen callback will notice that we nulled out server\n      // here.\n      self.server = null;\n      return;\n    }\n\n    // This stops listening but allows existing connections to\n    // complete gracefully.\n    self.server.close();\n    self.server = null;\n\n    // It doesn't seem to be necessary to do anything special to\n    // destroy an httpProxy proxyserver object.\n    self.proxy = null;\n\n    // Drop any held connections.\n    self.httpQueue?.forEach(function (c) {\n      c.res.statusCode = 500;\n      c.res.end();\n    });\n    self.httpQueue = [];\n\n    self.websocketQueue?.forEach(function (c) {\n      c.socket.destroy();\n    });\n    self.websocketQueue = [];\n\n    self.mode = \"hold\";\n  },\n\n  _tryHandleConnections: function () {\n    var self = this;\n\n    function attempt(resOrSocket, fn) {\n      try {\n        return fn();\n      } catch (e) {\n        if (typeof resOrSocket.writeHead === \"function\") {\n          resOrSocket.writeHead(400, {\n            'Content-Type': 'text/plain'\n          });\n        }\n        resOrSocket.end(\"Bad request\\n\");\n      }\n    }\n\n    while (self.httpQueue.length) {\n      if (self.mode !== \"errorpage\" && self.mode !== \"proxy\") {\n        break;\n      }\n\n      var c = self.httpQueue.shift();\n      if (self.mode === \"errorpage\") {\n        showErrorPage(c.res);\n      } else {\n        attempt(c.res, () => self.proxy.web(c.req, c.res, {\n          target: 'http://' + self.proxyToHost + ':' + self.proxyToPort\n        }));\n      }\n    }\n\n    while (self.websocketQueue.length) {\n      if (self.mode !== \"proxy\") {\n        break;\n      }\n\n      var c = self.websocketQueue.shift();\n      attempt(c.socket, () => self.proxy.ws(c.req, c.socket, c.head, {\n        target: 'http://' + self.proxyToHost + ':' + self.proxyToPort\n      }));\n    }\n  },\n\n  // The proxy can be in one of three modes:\n  // - \"hold\": hold connections until the mode changes\n  // - \"proxy\": connections are proxied to the configured port\n  // - \"errorpage\": an error page is served to HTTP connections, and\n  //   websocket connections are held\n  //\n  // The initial mode is \"hold\".\n  setMode: function (mode) {\n    var self = this;\n    self.mode = mode;\n    self._tryHandleConnections();\n  }\n});\n\nfunction showErrorPage(res) {\n  // XXX serve an app that shows the logs nicely and that also\n  // knows how to reload when the server comes back up\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.write(`\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>App crashing</title>\n    <style type='text/css'>\n      body { margin: 0; }\n      h3 {\n        margin: 0;\n        font-family: sans-serif;\n        padding: 20px 10px 10px 10px;\n        background: #eee;\n      }\n      pre { margin: 20px; }\n    </style>\n  </head>\n\n  <body>\n    <h3>Your app is crashing. Here's the latest log:</h3>\n\n    <pre>`);\n\n  runLog.getLog().forEach(function (item) {\n        res.write(Anser.ansiToHtml(Anser.escapeForHtml(item.message)) + \"\\n\");\n      });\n\n      res.write(`</pre>\n  </body>\n</html>`)\n\n  res.end();\n}\n\nexports.Proxy = Proxy;\n"],"file":"tools/runners/run-proxy.js.map"}