{"version":3,"sources":["meteor://ðŸ’»app/packages/caching-compiler/caching-compiler.js","meteor://ðŸ’»app/packages/caching-compiler/multi-file-caching-compiler.js"],"names":["fs","Plugin","path","createHash","Npm","require","assert","Future","LRU","async","CachingCompilerBase","compilerName","defaultCacheSize","maxParallelism","_compilerName","_maxParallelism","envVarPrefix","toUpperCase","debugEnvVar","_cacheDebugEnabled","process","env","cacheSizeEnvVar","_cacheSize","_diskCache","_callCount","getCacheKey","inputFile","Error","addCompileResult","compileResult","compileResultSize","stringifyCompileResult","JSON","stringify","parseCompileResult","stringifiedCompileResult","_parseJSONOrNull","json","parse","e","SyntaxError","_cacheDebug","message","console","log","setDiskCacheDirectory","diskCache","sourceMapSize","sm","mappings","length","sourcesContent","reduce","soFar","current","_deepHash","val","hash","type","update","keys","Object","Array","isArray","sort","forEach","key","ok","digest","_writeFileAsync","filename","contents","tempFilename","Random","id","writeFileSync","renameSync","writeFile","err","rename","_readFileOrNull","readFileSync","code","CachingCompiler","_cache","max","value","compileOneFile","processFilesForTarget","inputFiles","cacheMisses","future","eachLimit","cb","error","cacheKey","get","_readCache","getDisplayPath","push","set","_writeCacheAsync","resolver","wait","_cacheFilename","test","join","cacheFilename","_readAndParseCompileResultOrNull","cacheContents","raw","MultiFileCachingCompiler","allFiles","isRoot","getAbsoluteImportPath","getPackageName","getPathInPackage","Map","cacheKeyMap","importPath","allProcessedFuture","absoluteImportPath","cacheEntry","_cacheEntryValid","compileOneFileReturn","referencedImportPaths","cacheKeys","has","every","newlineIndex","indexOf","cacheKeysString","substring","compileResultString"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,KAAKC,OAAOD,EAAlB;AACA,IAAME,OAAOD,OAAOC,IAApB;;AACA,IAAMC,aAAaC,IAAIC,OAAJ,CAAY,QAAZ,EAAsBF,UAAzC;;AACA,IAAMG,SAASF,IAAIC,OAAJ,CAAY,QAAZ,CAAf;;AACA,IAAME,SAASH,IAAIC,OAAJ,CAAY,eAAZ,CAAf;;AACA,IAAMG,MAAMJ,IAAIC,OAAJ,CAAY,WAAZ,CAAZ;;AACA,IAAMI,QAAQL,IAAIC,OAAJ,CAAY,OAAZ,CAAd,C,CAEA;;;AACAK;AACE,qCAIG;AAAA,QAHDC,YAGC,QAHDA,YAGC;AAAA,QAFDC,gBAEC,QAFDA,gBAEC;AAAA,mCADDC,cACC;AAAA,QADDA,cACC,uCADgB,EAChB;AAAA;AACD,SAAKC,aAAL,GAAqBH,YAArB;AACA,SAAKI,eAAL,GAAuBF,cAAvB;AACA,QAAMG,eAAe,YAAYL,aAAaM,WAAb,EAAZ,GAAyC,SAA9D;AAEA,QAAMC,cAAcF,eAAe,OAAnC;AACA,SAAKG,kBAAL,GAA0B,CAAC,CAAEC,QAAQC,GAAR,CAAYH,WAAZ,CAA7B;AAEA,QAAMI,kBAAkBN,eAAe,MAAvC;AACA,SAAKO,UAAL,GAAkB,CAACH,QAAQC,GAAR,CAAYC,eAAZ,CAAD,IAAiCV,gBAAnD;AAEA,SAAKY,UAAL,GAAkB,IAAlB,CAXC,CAaD;;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACD,GApBH,CAsBE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AArCF,gCAsCEC,WAtCF;AAAA,yBAsCcC,SAtCd,EAsCyB;AACrB,YAAMC,MAAM,wDAAN,CAAN;AACD;;AAxCH;AAAA,OA0CE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAjDF,gCAkDEC,gBAlDF;AAAA,8BAkDmBF,SAlDnB,EAkD8BG,aAlD9B,EAkD6C;AACzC,YAAMF,MAAM,6DAAN,CAAN;AACD;;AApDH;AAAA,OAsDE;AACA;AACA;;;AAxDF,gCAyDEG,iBAzDF;AAAA,+BAyDoBD,aAzDpB,EAyDmC;AAC/B,YAAMF,MAAM,8DAAN,CAAN;AACD;;AA3DH;AAAA,OA6DE;AACA;;;AA9DF,gCA+DEI,sBA/DF;AAAA,oCA+DyBF,aA/DzB,EA+DwC;AACpC,aAAOG,KAAKC,SAAL,CAAeJ,aAAf,CAAP;AACD;;AAjEH;AAAA,OAkEE;AACA;AACA;AACA;AACA;;;AAtEF,gCAuEEK,kBAvEF;AAAA,gCAuEqBC,wBAvErB,EAuE+C;AAC3C,aAAO,KAAKC,gBAAL,CAAsBD,wBAAtB,CAAP;AACD;;AAzEH;AAAA;;AAAA,gCA0EEC,gBA1EF;AAAA,8BA0EmBC,IA1EnB,EA0EyB;AACrB,UAAI;AACF,eAAOL,KAAKM,KAAL,CAAWD,IAAX,CAAP;AACD,OAFD,CAEE,OAAOE,CAAP,EAAU;AACV,YAAIA,aAAaC,WAAjB,EACE,OAAO,IAAP;AACF,cAAMD,CAAN;AACD;AACF;;AAlFH;AAAA;;AAAA,gCAoFEE,WApFF;AAAA,yBAoFcC,OApFd,EAoFuB;AACnB,UAAI,CAAC,KAAKxB,kBAAV,EACE;AACFyB,cAAQC,GAAR,YAAsB,KAAK/B,aAA3B,WAAgD6B,OAAhD;AACD;;AAxFH;AAAA;;AAAA,gCA0FEG,qBA1FF;AAAA,mCA0FwBC,SA1FxB,EA0FmC;AAC/B,UAAI,KAAKvB,UAAT,EACE,MAAMI,MAAM,qCAAN,CAAN;AACF,WAAKJ,UAAL,GAAkBuB,SAAlB;AACD;;AA9FH;AAAA,OAgGE;AACA;;;AAjGF,gCAkGEC,aAlGF;AAAA,2BAkGgBC,EAlGhB,EAkGoB;AAChB,UAAI,CAAEA,EAAN,EAAU,OAAO,CAAP,CADM,CAEhB;AACA;;AACA,aAAOA,GAAGC,QAAH,CAAYC,MAAZ,GACH,CAACF,GAAGG,cAAH,IAAqB,EAAtB,EAA0BC,MAA1B,CAAiC,UAAUC,KAAV,EAAiBC,OAAjB,EAA0B;AAC3D,eAAOD,SAASC,UAAUA,QAAQJ,MAAlB,GAA2B,CAApC,CAAP;AACD,OAFC,EAEC,CAFD,CADJ;AAID;;AA1GH;AAAA,OA4GE;AACA;;;AA7GF,gCA8GEK,SA9GF;AAAA,uBA8GYC,GA9GZ,EA8GiB;AAAA;;AACb,UAAMC,OAAOvD,WAAW,MAAX,CAAb;AACA,UAAIwD,cAAcF,GAAd,uDAAcA,GAAd,CAAJ;;AAEA,UAAIA,QAAQ,IAAZ,EAAkB;AAChBE,eAAO,MAAP;AACD;;AACDD,WAAKE,MAAL,CAAYD,OAAO,IAAnB;;AAEA,cAAQA,IAAR;AACA,aAAK,QAAL;AACE,cAAME,OAAOC,OAAOD,IAAP,CAAYJ,GAAZ,CAAb,CADF,CAGE;;AACA,cAAI,CAAEM,MAAMC,OAAN,CAAcP,GAAd,CAAN,EAA0B;AACxBI,iBAAKI,IAAL;AACD;;AAEDJ,eAAKK,OAAL,CAAa,UAACC,GAAD,EAAS;AACpB,gBAAI,OAAOV,IAAIU,GAAJ,CAAP,KAAoB,UAAxB,EAAoC;AAClC;AACA;AACA;AACD;;AAEDT,iBAAKE,MAAL,CAAYO,MAAM,IAAlB,EAAwBP,MAAxB,CAA+B,MAAKJ,SAAL,CAAeC,IAAIU,GAAJ,CAAf,CAA/B;AACD,WARD;AAUA;;AAEF,aAAK,UAAL;AACE7D,iBAAO8D,EAAP,CAAU,KAAV,EAAiB,8BAAjB;AACA;;AAEF;AACEV,eAAKE,MAAL,CAAY,KAAKH,GAAjB;AACA;AA3BF;;AA8BA,aAAOC,KAAKW,MAAL,CAAY,KAAZ,CAAP;AACD;;AAtJH;AAAA,OAwJE;AACA;;;AAzJF,gCA0JEC,eA1JF;AAAA,6BA0JkBC,QA1JlB,EA0J4BC,QA1J5B,EA0JsC;AAClC,UAAMC,eAAeF,WAAW,OAAX,GAAqBG,OAAOC,EAAP,EAA1C;;AACA,UAAI,KAAKxD,kBAAT,EAA6B;AAC3B;AACA,YAAI;AACFnB,aAAG4E,aAAH,CAAiBH,YAAjB,EAA+BD,QAA/B;AACAxE,aAAG6E,UAAH,CAAcJ,YAAd,EAA4BF,QAA5B;AACD,SAHD,CAGE,OAAO/B,CAAP,EAAU,CACV;AACD;AACF,OARD,MAQO;AACLxC,WAAG8E,SAAH,CAAaL,YAAb,EAA2BD,QAA3B,EAAqC,eAAO;AAC1C;AACA,cAAI,CAAEO,GAAN,EAAW;AACT/E,eAAGgF,MAAH,CAAUP,YAAV,EAAwBF,QAAxB,EAAkC,eAAO,CAAE,CAA3C;AACD;AACF,SALD;AAMD;AACF;;AA5KH;AAAA,OA8KE;AACA;;;AA/KF,gCAgLEU,eAhLF;AAAA,6BAgLkBV,QAhLlB,EAgL4B;AACxB,UAAI;AACF,eAAOvE,GAAGkF,YAAH,CAAgBX,QAAhB,EAA0B,MAA1B,CAAP;AACD,OAFD,CAEE,OAAO/B,CAAP,EAAU;AACV,YAAIA,KAAKA,EAAE2C,IAAF,KAAW,QAApB,EACE,OAAO,IAAP;AACF,cAAM3C,CAAN;AACD;AACF;;AAxLH;AAAA;;AAAA;AAAA,I,CA2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA4C;AAAA;;AACE,kCAIG;AAAA,QAHDzE,YAGC,SAHDA,YAGC;AAAA,QAFDC,gBAEC,SAFDA,gBAEC;AAAA,qCADDC,cACC;AAAA,QADDA,cACC,wCADgB,EAChB;AAAA;;AAGD;AAHC,gEACD,gCAAM;AAACF,gCAAD;AAAeC,wCAAf;AAAiCC;AAAjC,KAAN,CADC;;AAID,WAAKwE,MAAL,GAAc,IAAI7E,GAAJ,CAAQ;AACpB8E,WAAK,OAAK/D,UADU;AAEpB4B,cAAQ,UAACoC,KAAD;AAAA,eAAW,OAAKxD,iBAAL,CAAuBwD,KAAvB,CAAX;AAAA;AAFY,KAAR,CAAd;AAJC;AAQF,GAbH,CAeE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA7BF,4BA8BEC,cA9BF;AAAA,4BA8BiB7D,SA9BjB,EA8B4B;AACxB,YAAMC,MAAM,2DAAN,CAAN;AACD;;AAhCH;AAAA,OAkCE;AACA;AACA;AACA;;;AArCF,4BAsCE6D,qBAtCF;AAAA,mCAsCwBC,UAtCxB,EAsCoC;AAAA;;AAChC,UAAMC,cAAc,EAApB;AAEA,UAAMC,SAAS,IAAIrF,MAAJ,EAAf;AACAE,YAAMoF,SAAN,CAAgBH,UAAhB,EAA4B,KAAK3E,eAAjC,EAAkD,UAACY,SAAD,EAAYmE,EAAZ,EAAmB;AACnE,YAAIC,QAAQ,IAAZ;;AACA,YAAI;AACF,cAAMC,WAAW,OAAKxC,SAAL,CAAe,OAAK9B,WAAL,CAAiBC,SAAjB,CAAf,CAAjB;;AACA,cAAIG,gBAAgB,OAAKuD,MAAL,CAAYY,GAAZ,CAAgBD,QAAhB,CAApB;;AAEA,cAAI,CAAElE,aAAN,EAAqB;AACnBA,4BAAgB,OAAKoE,UAAL,CAAgBF,QAAhB,CAAhB;;AACA,gBAAIlE,aAAJ,EAAmB;AACjB,qBAAKY,WAAL,aAA4Bf,UAAUwE,cAAV,EAA5B;AACD;AACF;;AAED,cAAI,CAAErE,aAAN,EAAqB;AACnB6D,wBAAYS,IAAZ,CAAiBzE,UAAUwE,cAAV,EAAjB;AACArE,4BAAgB,OAAK0D,cAAL,CAAoB7D,SAApB,CAAhB;;AAEA,gBAAI,CAAEG,aAAN,EAAqB;AACnB;AACA;AACA;AACD,aARkB,CAUnB;;;AACA,mBAAKuD,MAAL,CAAYgB,GAAZ,CAAgBL,QAAhB,EAA0BlE,aAA1B;;AACA,mBAAKwE,gBAAL,CAAsBN,QAAtB,EAAgClE,aAAhC;AACD;;AAED,iBAAKD,gBAAL,CAAsBF,SAAtB,EAAiCG,aAAjC;AACD,SA3BD,CA2BE,OAAOU,CAAP,EAAU;AACVuD,kBAAQvD,CAAR;AACD,SA7BD,SA6BU;AACRsD,aAAGC,KAAH;AACD;AACF,OAlCD,EAkCGH,OAAOW,QAAP,EAlCH;AAmCAX,aAAOY,IAAP;;AAEA,UAAI,KAAKrF,kBAAT,EAA6B;AAC3BwE,oBAAY1B,IAAZ;;AACA,aAAKvB,WAAL,YACY,EAAE,KAAKjB,UADnB,cACwCQ,KAAKC,SAAL,CAAeyD,WAAf,CADxC;AAED;AACF;;AApFH;AAAA;;AAAA,4BAsFEc,cAtFF;AAAA,4BAsFiBT,QAtFjB,EAsF2B;AACvB;AACA;AACA,UAAI,CAAC,cAAcU,IAAd,CAAmBV,QAAnB,CAAL,EAAmC;AACjC,cAAMpE,MAAM,mBAAmBoE,QAAzB,CAAN;AACD;;AACD,aAAO9F,KAAKyG,IAAL,CAAU,KAAKnF,UAAf,EAA2BwE,WAAW,QAAtC,CAAP;AACD;;AA7FH;AAAA,OA8FE;AACA;;;AA/FF,4BAgGEE,UAhGF;AAAA,wBAgGaF,QAhGb,EAgGuB;AACnB,UAAI,CAAE,KAAKxE,UAAX,EAAuB;AACrB,eAAO,IAAP;AACD;;AACD,UAAMoF,gBAAgB,KAAKH,cAAL,CAAoBT,QAApB,CAAtB;;AACA,UAAMlE,gBAAgB,KAAK+E,gCAAL,CAAsCD,aAAtC,CAAtB;;AACA,UAAI,CAAE9E,aAAN,EAAqB;AACnB,eAAO,IAAP;AACD;;AACD,WAAKuD,MAAL,CAAYgB,GAAZ,CAAgBL,QAAhB,EAA0BlE,aAA1B;;AACA,aAAOA,aAAP;AACD;;AA3GH;AAAA;;AAAA,4BA4GEwE,gBA5GF;AAAA,8BA4GmBN,QA5GnB,EA4G6BlE,aA5G7B,EA4G4C;AACxC,UAAI,CAAE,KAAKN,UAAX,EACE;;AACF,UAAMoF,gBAAgB,KAAKH,cAAL,CAAoBT,QAApB,CAAtB;;AACA,UAAMc,gBAAgB,KAAK9E,sBAAL,CAA4BF,aAA5B,CAAtB;;AACA,WAAKwC,eAAL,CAAqBsC,aAArB,EAAoCE,aAApC;AACD;;AAlHH;AAAA,OAoHE;AACA;;;AArHF,4BAsHED,gCAtHF;AAAA,8CAsHmCtC,QAtHnC,EAsH6C;AACzC,UAAMwC,MAAM,KAAK9B,eAAL,CAAqBV,QAArB,CAAZ;;AACA,aAAO,KAAKpC,kBAAL,CAAwB4E,GAAxB,CAAP;AACD;;AAzHH;AAAA;;AAAA;AAAA,EAAgDrG,mBAAhD,6F;;;;;;;;;;;;;;;;;;;;;;;;;ACjPA,IAAMR,OAAOD,OAAOC,IAApB;;AACA,IAAMK,SAASH,IAAIC,OAAJ,CAAY,eAAZ,CAAf;;AACA,IAAMG,MAAMJ,IAAIC,OAAJ,CAAY,WAAZ,CAAZ;;AACA,IAAMI,QAAQL,IAAIC,OAAJ,CAAY,OAAZ,CAAd,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA2G;AAAA;;AAEE,0CAIG;AAAA,QAHDrG,YAGC,QAHDA,YAGC;AAAA,QAFDC,gBAEC,QAFDA,gBAEC;AAAA,QADDC,cACC,QADDA,cACC;AAAA;;AAGD;AACA;AACA;AALC,+DACD,gCAAM;AAACF,gCAAD;AAAeC,wCAAf;AAAiCC;AAAjC,KAAN,CADC;;AAMD,UAAKwE,MAAL,GAAc,IAAI7E,GAAJ,CAAQ;AACpB8E,WAAK,MAAK/D,UADU;AAEpB;AACA4B,cAAQ,UAACoC,KAAD;AAAA,eAAW,MAAKxD,iBAAL,CAAuBwD,MAAMzD,aAA7B,CAAX;AAAA;AAHY,KAAR,CAAd;AANC;AAWF,GAjBH,CAmBE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAxCF,qCAyCE0D,cAzCF;AAAA,4BAyCiB7D,SAzCjB,EAyC4BsF,QAzC5B,EAyCsC;AAClC,YAAMrF,MACJ,oEADI,CAAN;AAED;;AA5CH;AAAA,OA8CE;AACA;AACA;AACA;;;AAjDF,qCAkDEsF,MAlDF;AAAA,oBAkDSvF,SAlDT,EAkDoB;AAChB,aAAO,IAAP;AACD;;AApDH;AAAA,OAsDE;AACA;AACA;AACA;;;AAzDF,qCA0DEwF,qBA1DF;AAAA,mCA0DwBxF,SA1DxB,EA0DmC;AAC/B,UAAIA,UAAUyF,cAAV,OAA+B,IAAnC,EAAyC;AACvC,eAAO,QAAQzF,UAAU0F,gBAAV,EAAf;AACD;;AACD,aAAO,MAAM1F,UAAUyF,cAAV,EAAN,GAAmC,IAAnC,GACHzF,UAAU0F,gBAAV,EADJ;AAED;;AAhEH;AAAA,OAkEE;;;AAlEF,qCAmEE5B,qBAnEF;AAAA,mCAmEwBC,UAnExB,EAmEoC;AAAA;;AAChC,UAAMuB,WAAW,IAAIK,GAAJ,EAAjB;AACA,UAAMC,cAAc,IAAID,GAAJ,EAApB;AACA,UAAM3B,cAAc,EAApB;AAEAD,iBAAWxB,OAAX,CAAmB,UAACvC,SAAD,EAAe;AAChC,YAAM6F,aAAa,OAAKL,qBAAL,CAA2BxF,SAA3B,CAAnB;;AACAsF,iBAASZ,GAAT,CAAamB,UAAb,EAAyB7F,SAAzB;AACA4F,oBAAYlB,GAAZ,CAAgBmB,UAAhB,EAA4B,OAAKhE,SAAL,CAAe,OAAK9B,WAAL,CAAiBC,SAAjB,CAAf,CAA5B;AACD,OAJD;AAMA,UAAM8F,qBAAqB,IAAIlH,MAAJ,EAA3B;AACAE,YAAMoF,SAAN,CAAgBH,UAAhB,EAA4B,KAAK3E,eAAjC,EAAkD,UAACY,SAAD,EAAYmE,EAAZ,EAAmB;AACnE,YAAIC,QAAQ,IAAZ;;AACA,YAAI;AACF;AACA;AACA,cAAI,CAAC,OAAKmB,MAAL,CAAYvF,SAAZ,CAAL,EAA6B;AAC3B;AACD;;AAED,cAAM+F,qBAAqB,OAAKP,qBAAL,CAA2BxF,SAA3B,CAA3B;;AACA,cAAIgG,aAAa,OAAKtC,MAAL,CAAYY,GAAZ,CAAgByB,kBAAhB,CAAjB;;AACA,cAAI,CAAEC,UAAN,EAAkB;AAChBA,yBAAa,OAAKzB,UAAL,CAAgBwB,kBAAhB,CAAb;;AACA,gBAAIC,UAAJ,EAAgB;AACd,qBAAKjF,WAAL,aAA4BgF,kBAA5B;AACD;AACF;;AACD,cAAI,EAAGC,cAAc,OAAKC,gBAAL,CAAsBD,UAAtB,EAAkCJ,WAAlC,CAAjB,CAAJ,EAAsE;AAAA;;AACpE5B,wBAAYS,IAAZ,CAAiBzE,UAAUwE,cAAV,EAAjB;;AAEA,gBAAM0B,uBAAuB,OAAKrC,cAAL,CAAoB7D,SAApB,EAA+BsF,QAA/B,CAA7B;;AACA,gBAAI,CAAEY,oBAAN,EAA4B;AAC1B;AACA;AACA;AACD;;AARmE,gBAS7D/F,aAT6D,GASrB+F,oBATqB,CAS7D/F,aAT6D;AAAA,gBAS9CgG,qBAT8C,GASrBD,oBATqB,CAS9CC,qBAT8C;AAWpEH,yBAAa;AACX7F,0CADW;AAEXiG,sDAEGL,kBAFH,IAEwBH,YAAYtB,GAAZ,CAAgByB,kBAAhB,CAFxB;AAFW,aAAb,CAXoE,CAmBpE;;AACAI,kCAAsB5D,OAAtB,CAA8B,UAAChE,IAAD,EAAU;AACtC,kBAAI,CAACqH,YAAYS,GAAZ,CAAgB9H,IAAhB,CAAL,EAA4B;AAC1B,sBAAM0B,wCAAuC1B,IAAvC,CAAN;AACD;;AACDyH,yBAAWI,SAAX,CAAqB7H,IAArB,IAA6BqH,YAAYtB,GAAZ,CAAgB/F,IAAhB,CAA7B;AACD,aALD,EApBoE,CA2BpE;;AACA,mBAAKmF,MAAL,CAAYgB,GAAZ,CAAgBqB,kBAAhB,EAAoCC,UAApC;;AACA,mBAAKrB,gBAAL,CAAsBoB,kBAAtB,EAA0CC,UAA1C;AACD;;AAED,iBAAK9F,gBAAL,CAAsBF,SAAtB,EAAiCgG,WAAW7F,aAA5C;AACD,SAhDD,CAgDE,OAAOU,CAAP,EAAU;AACVuD,kBAAQvD,CAAR;AACD,SAlDD,SAkDU;AACRsD,aAAGC,KAAH;AACD;AACF,OAvDD,EAuDG0B,mBAAmBlB,QAAnB,EAvDH;AAwDAkB,yBAAmBjB,IAAnB;;AAEA,UAAI,KAAKrF,kBAAT,EAA6B;AAC3BwE,oBAAY1B,IAAZ;;AACA,aAAKvB,WAAL,YACY,EAAE,KAAKjB,UADnB,cACwCQ,KAAKC,SAAL,CAAeyD,WAAf,CADxC;AAED;AACF;;AA9IH;AAAA;;AAAA,qCAgJEiC,gBAhJF;AAAA,8BAgJmBD,UAhJnB,EAgJ+BJ,WAhJ/B,EAgJ4C;AACxC,aAAOzD,OAAOD,IAAP,CAAY8D,WAAWI,SAAvB,EAAkCE,KAAlC,CACL,UAAC/H,IAAD;AAAA,eAAUyH,WAAWI,SAAX,CAAqB7H,IAArB,MAA+BqH,YAAYtB,GAAZ,CAAgB/F,IAAhB,CAAzC;AAAA,OADK,CAAP;AAGD;;AApJH;AAAA,OAsJE;AACA;AACA;;;AAxJF,qCAyJEuG,cAzJF;AAAA,4BAyJiBiB,kBAzJjB,EAyJqC;AACjC,aAAOxH,KAAKyG,IAAL,CAAU,KAAKnF,UAAf,EACU,KAAKgC,SAAL,CAAekE,kBAAf,IAAqC,QAD/C,CAAP;AAED;;AA5JH;AAAA,OA6JE;AACA;;;AA9JF,qCA+JExB,UA/JF;AAAA,wBA+JawB,kBA/Jb,EA+JiC;AAC7B,UAAI,CAAE,KAAKlG,UAAX,EAAuB;AACrB,eAAO,IAAP;AACD;;AACD,UAAMoF,gBAAgB,KAAKH,cAAL,CAAoBiB,kBAApB,CAAtB;;AACA,UAAMX,MAAM,KAAK9B,eAAL,CAAqB2B,aAArB,CAAZ;;AACA,UAAI,CAACG,GAAL,EAAU;AACR,eAAO,IAAP;AACD,OAR4B,CAU7B;;;AACA,UAAMmB,eAAenB,IAAIoB,OAAJ,CAAY,IAAZ,CAArB;;AACA,UAAID,iBAAiB,CAAC,CAAtB,EAAyB;AACvB,eAAO,IAAP;AACD;;AACD,UAAME,kBAAkBrB,IAAIsB,SAAJ,CAAc,CAAd,EAAiBH,YAAjB,CAAxB;AACA,UAAMI,sBAAsBvB,IAAIsB,SAAJ,CAAcH,eAAe,CAA7B,CAA5B;;AAEA,UAAMH,YAAY,KAAK1F,gBAAL,CAAsB+F,eAAtB,CAAlB;;AACA,UAAI,CAACL,SAAL,EAAgB;AACd,eAAO,IAAP;AACD;;AACD,UAAMjG,gBAAgB,KAAKK,kBAAL,CAAwBmG,mBAAxB,CAAtB;;AACA,UAAI,CAAExG,aAAN,EAAqB;AACnB,eAAO,IAAP;AACD;;AAED,UAAM6F,aAAa;AAAC7F,oCAAD;AAAgBiG;AAAhB,OAAnB;;AACA,WAAK1C,MAAL,CAAYgB,GAAZ,CAAgBqB,kBAAhB,EAAoCC,UAApC;;AACA,aAAOA,UAAP;AACD;;AA7LH;AAAA;;AAAA,qCA8LErB,gBA9LF;AAAA,8BA8LmBoB,kBA9LnB,EA8LuCC,UA9LvC,EA8LmD;AAC/C,UAAI,CAAE,KAAKnG,UAAX,EAAuB;AACrB,eAAO,IAAP;AACD;;AACD,UAAMoF,gBAAgB,KAAKH,cAAL,CAAoBiB,kBAApB,CAAtB;;AACA,UAAMZ,gBACE7E,KAAKC,SAAL,CAAeyF,WAAWI,SAA1B,IAAuC,IAAvC,GACE,KAAK/F,sBAAL,CAA4B2F,WAAW7F,aAAvC,CAFV;;AAGA,WAAKwC,eAAL,CAAqBsC,aAArB,EAAoCE,aAApC;AACD;;AAvMH;AAAA;;AAAA;AAAA,EACQpG,mBADR,4F","file":"/packages/caching-compiler.js","sourcesContent":["const fs = Plugin.fs;\nconst path = Plugin.path;\nconst createHash = Npm.require('crypto').createHash;\nconst assert = Npm.require('assert');\nconst Future = Npm.require('fibers/future');\nconst LRU = Npm.require('lru-cache');\nconst async = Npm.require('async');\n\n// Base class for CachingCompiler and MultiFileCachingCompiler.\nCachingCompilerBase = class CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    this._compilerName = compilerName;\n    this._maxParallelism = maxParallelism;\n    const envVarPrefix = 'METEOR_' + compilerName.toUpperCase() + '_CACHE_';\n\n    const debugEnvVar = envVarPrefix + 'DEBUG';\n    this._cacheDebugEnabled = !! process.env[debugEnvVar];\n\n    const cacheSizeEnvVar = envVarPrefix + 'SIZE';\n    this._cacheSize = +process.env[cacheSizeEnvVar] || defaultCacheSize;\n\n    this._diskCache = null;\n\n    // For testing.\n    this._callCount = 0;\n  }\n\n  // Your subclass must override this method to define the key used to identify\n  // a particular version of an InputFile.\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), returns a cache key that represents\n  // it. This cache key can be any JSON value (it will be converted internally\n  // into a hash).  This should reflect any aspect of the InputFile that affects\n  // the output of `compileOneFile`. Typically you'll want to include\n  // `inputFile.getDeclaredExports()`, and perhaps\n  // `inputFile.getPathInPackage()` or `inputFile.getDeclaredExports` if\n  // `compileOneFile` pays attention to them.\n  //\n  // Note that for MultiFileCachingCompiler, your cache key doesn't need to\n  // include the file's path, because that is automatically taken into account\n  // by the implementation. CachingCompiler subclasses can choose whether or not\n  // to include the file's path in the cache key.\n  getCacheKey(inputFile) {\n    throw Error('CachingCompiler subclass should implement getCacheKey!');\n  }\n\n  // Your subclass must override this method to define how a CompileResult\n  // translates into adding assets to the bundle.\n  //\n  // This method is given an InputFile (the data type passed to\n  // processFilesForTarget as part of the Plugin.registerCompiler API) and a\n  // CompileResult (either returned directly from compileOneFile or read from\n  // the cache).  It should call methods like `inputFile.addJavaScript`\n  // and `inputFile.error`.\n  addCompileResult(inputFile, compileResult) {\n    throw Error('CachingCompiler subclass should implement addCompileResult!');\n  }\n\n  // Your subclass must override this method to define the size of a\n  // CompilerResult (used by the in-memory cache to limit the total amount of\n  // data cached).\n  compileResultSize(compileResult) {\n    throw Error('CachingCompiler subclass should implement compileResultSize!');\n  }\n\n  // Your subclass may override this method to define an alternate way of\n  // stringifying CompilerResults.  Takes a CompileResult and returns a string.\n  stringifyCompileResult(compileResult) {\n    return JSON.stringify(compileResult);\n  }\n  // Your subclass may override this method to define an alternate way of\n  // parsing CompilerResults from string.  Takes a string and returns a\n  // CompileResult.  If the string doesn't represent a valid CompileResult, you\n  // may want to return null instead of throwing, which will make\n  // CachingCompiler ignore the cache.\n  parseCompileResult(stringifiedCompileResult) {\n    return this._parseJSONOrNull(stringifiedCompileResult);\n  }\n  _parseJSONOrNull(json) {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      if (e instanceof SyntaxError)\n        return null;\n      throw e;\n    }\n  }\n\n  _cacheDebug(message) {\n    if (!this._cacheDebugEnabled)\n      return;\n    console.log(`CACHE(${ this._compilerName }): ${ message }`);\n  }\n\n  setDiskCacheDirectory(diskCache) {\n    if (this._diskCache)\n      throw Error('setDiskCacheDirectory called twice?');\n    this._diskCache = diskCache;\n  }\n\n  // Since so many compilers will need to calculate the size of a SourceMap in\n  // their compileResultSize, this method is provided.\n  sourceMapSize(sm) {\n    if (! sm) return 0;\n    // sum the length of sources and the mappings, the size of\n    // metadata is ignored, but it is not a big deal\n    return sm.mappings.length\n      + (sm.sourcesContent || []).reduce(function (soFar, current) {\n        return soFar + (current ? current.length : 0);\n      }, 0);\n  }\n\n  // Borrowed from another MIT-licensed project that benjamn wrote:\n  // https://github.com/reactjs/commoner/blob/235d54a12c/lib/util.js#L136-L168\n  _deepHash(val) {\n    const hash = createHash('sha1');\n    let type = typeof val;\n\n    if (val === null) {\n      type = 'null';\n    }\n    hash.update(type + '\\0');\n\n    switch (type) {\n    case 'object':\n      const keys = Object.keys(val);\n\n      // Array keys will already be sorted.\n      if (! Array.isArray(val)) {\n        keys.sort();\n      }\n\n      keys.forEach((key) => {\n        if (typeof val[key] === 'function') {\n          // Silently ignore nested methods, but nevertheless complain below\n          // if the root value is a function.\n          return;\n        }\n\n        hash.update(key + '\\0').update(this._deepHash(val[key]));\n      });\n\n      break;\n\n    case 'function':\n      assert.ok(false, 'cannot hash function objects');\n      break;\n\n    default:\n      hash.update('' + val);\n      break;\n    }\n\n    return hash.digest('hex');\n  }\n\n  // We want to write the file atomically. But we also don't want to block\n  // processing on the file write.\n  _writeFileAsync(filename, contents) {\n    const tempFilename = filename + '.tmp.' + Random.id();\n    if (this._cacheDebugEnabled) {\n      // Write cache file synchronously when cache debugging enabled.\n      try {\n        fs.writeFileSync(tempFilename, contents);\n        fs.renameSync(tempFilename, filename);\n      } catch (e) {\n        // ignore errors, it's just a cache\n      }\n    } else {\n      fs.writeFile(tempFilename, contents, err => {\n        // ignore errors, it's just a cache\n        if (! err) {\n          fs.rename(tempFilename, filename, err => {});\n        }\n      });\n    }\n  }\n\n  // Helper function. Returns the body of the file as a string, or null if it\n  // doesn't exist.\n  _readFileOrNull(filename) {\n    try {\n      return fs.readFileSync(filename, 'utf8');\n    } catch (e) {\n      if (e && e.code === 'ENOENT')\n        return null;\n      throw e;\n    }\n  }\n}\n\n// CachingCompiler is a class designed to be used with Plugin.registerCompiler\n// which implements in-memory and on-disk caches for the files that it\n// processes.  You should subclass CachingCompiler and define the following\n// methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.\n//\n// CachingCompiler assumes that files are processed independently of each other;\n// there is no 'import' directive allowing one file to reference another.  That\n// is, editing one file should only require that file to be rebuilt, not other\n// files.\n//\n// The data that is cached for each file is of a type that is (implicitly)\n// defined by your subclass. CachingCompiler refers to this type as\n// `CompileResult`, but this isn't a single type: it's up to your subclass to\n// decide what type of data this is.  You should document what your subclass's\n// CompileResult type is.\n//\n// Your subclass's compiler should call the superclass compiler specifying the\n// compiler name (used to generate environment variables for debugging and\n// tweaking in-memory cache size) and the default cache size.\n//\n// By default, CachingCompiler processes each file in \"parallel\". That is, if it\n// needs to yield to read from the disk cache, or if getCacheKey,\n// compileOneFile, or addCompileResult yields, it will start processing the next\n// few files. To set how many files can be processed in parallel (including\n// setting it to 1 if your subclass doesn't support any parallelism), pass the\n// maxParallelism option to the superclass constructor.\n//\n// For example (using ES2015 via the ecmascript package):\n//\n//   class AwesomeCompiler extends CachingCompiler {\n//     constructor() {\n//       super({\n//         compilerName: 'awesome',\n//         defaultCacheSize: 1024*1024*10,\n//       });\n//     }\n//     // ... define the other methods\n//   }\n//   Plugin.registerCompile({\n//     extensions: ['awesome'],\n//   }, () => new AwesomeCompiler());\n//\n// XXX maybe compileResultSize and stringifyCompileResult should just be methods\n// on CompileResult? Sort of hard to do that with parseCompileResult.\nCachingCompiler = class CachingCompiler extends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from a hashed cache key to a compileResult.\n    this._cache = new LRU({\n      max: this._cacheSize,\n      length: (value) => this.compileResultSize(value),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), compiles the file and returns a\n  // CompileResult (the cacheable data type specific to your subclass).\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile) {\n    throw Error('CachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API. If\n  // you have processing you want to perform at the beginning or end of a\n  // processing phase, you may want to override this method and call the\n  // superclass implementation from within your method.\n  processFilesForTarget(inputFiles) {\n    const cacheMisses = [];\n\n    const future = new Future;\n    async.eachLimit(inputFiles, this._maxParallelism, (inputFile, cb) => {\n      let error = null;\n      try {\n        const cacheKey = this._deepHash(this.getCacheKey(inputFile));\n        let compileResult = this._cache.get(cacheKey);\n\n        if (! compileResult) {\n          compileResult = this._readCache(cacheKey);\n          if (compileResult) {\n            this._cacheDebug(`Loaded ${ inputFile.getDisplayPath() }`);\n          }\n        }\n\n        if (! compileResult) {\n          cacheMisses.push(inputFile.getDisplayPath());\n          compileResult = this.compileOneFile(inputFile);\n\n          if (! compileResult) {\n            // compileOneFile should have called inputFile.error.\n            //  We don't cache failures for now.\n            return;\n          }\n\n          // Save what we've compiled.\n          this._cache.set(cacheKey, compileResult);\n          this._writeCacheAsync(cacheKey, compileResult);\n        }\n\n        this.addCompileResult(inputFile, compileResult);\n      } catch (e) {\n        error = e;\n      } finally {\n        cb(error);\n      }\n    }, future.resolver());\n    future.wait();\n\n    if (this._cacheDebugEnabled) {\n      cacheMisses.sort();\n      this._cacheDebug(\n        `Ran (#${ ++this._callCount }) on: ${ JSON.stringify(cacheMisses) }`);\n    }\n  }\n\n  _cacheFilename(cacheKey) {\n    // We want cacheKeys to be hex so that they work on any FS and never end in\n    // .cache.\n    if (!/^[a-f0-9]+$/.test(cacheKey)) {\n      throw Error('bad cacheKey: ' + cacheKey);\n    }\n    return path.join(this._diskCache, cacheKey + '.cache');\n  }\n  // Load a cache entry from disk. Returns the compileResult object\n  // and loads it into the in-memory cache too.\n  _readCache(cacheKey) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const compileResult = this._readAndParseCompileResultOrNull(cacheFilename);\n    if (! compileResult) {\n      return null;\n    }\n    this._cache.set(cacheKey, compileResult);\n    return compileResult;\n  }\n  _writeCacheAsync(cacheKey, compileResult) {\n    if (! this._diskCache)\n      return;\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const cacheContents = this.stringifyCompileResult(compileResult);\n    this._writeFileAsync(cacheFilename, cacheContents);\n  }\n\n  // Returns null if the file does not exist or can't be parsed; otherwise\n  // returns the parsed compileResult in the file.\n  _readAndParseCompileResultOrNull(filename) {\n    const raw = this._readFileOrNull(filename);\n    return this.parseCompileResult(raw);\n  }\n}\n","const path = Plugin.path;\nconst Future = Npm.require('fibers/future');\nconst LRU = Npm.require('lru-cache');\nconst async = Npm.require('async');\n\n// MultiFileCachingCompiler is like CachingCompiler, but for implementing\n// languages which allow files to reference each other, such as CSS\n// preprocessors with `@import` directives.\n//\n// Like CachingCompiler, you should subclass MultiFileCachingCompiler and define\n// the following methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.  compileOneFile gets an additional allFiles argument and\n// returns an array of referenced import paths in addition to the CompileResult.\n// You may also override isRoot and getAbsoluteImportPath to customize\n// MultiFileCachingCompiler further.\nMultiFileCachingCompiler = class MultiFileCachingCompiler\nextends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from absolute import path to { compileResult, cacheKeys }, where\n    // cacheKeys is an object mapping from absolute import path to hashed\n    // cacheKey for each file referenced by this file (including itself).\n    this._cache = new LRU({\n      max: this._cacheSize,\n      // We ignore the size of cacheKeys here.\n      length: (value) => this.compileResultSize(value.compileResult),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Arguments:\n  //   - inputFile is the InputFile to process\n  //   - allFiles is a a Map mapping from absolute import path to InputFile of\n  //     all files being processed in the target\n  // Returns an object with keys:\n  //   - compileResult: the CompileResult (the cacheable data type specific to\n  //     your subclass).\n  //   - referencedImportPaths: an array of absolute import paths of files\n  //     which were refererenced by the current file.  The current file\n  //     is included implicitly.\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile, allFiles) {\n    throw Error(\n      'MultiFileCachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // Your subclass may override this to declare that a file is not a \"root\" ---\n  // ie, it can be included from other files but is not processed on its own. In\n  // this case, MultiFileCachingCompiler won't waste time trying to look for a\n  // cache for its compilation on disk.\n  isRoot(inputFile) {\n    return true;\n  }\n\n  // Returns the absolute import path for an InputFile. By default, this is a\n  // path is a path of the form \"{package}/path/to/file\" for files in packages\n  // and \"{}/path/to/file\" for files in apps. Your subclass may override and/or\n  // call this method.\n  getAbsoluteImportPath(inputFile) {\n    if (inputFile.getPackageName() === null) {\n      return '{}/' + inputFile.getPathInPackage();\n    }\n    return '{' + inputFile.getPackageName() + '}/'\n      + inputFile.getPathInPackage();\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API.\n  processFilesForTarget(inputFiles) {\n    const allFiles = new Map;\n    const cacheKeyMap = new Map;\n    const cacheMisses = [];\n\n    inputFiles.forEach((inputFile) => {\n      const importPath = this.getAbsoluteImportPath(inputFile);\n      allFiles.set(importPath, inputFile);\n      cacheKeyMap.set(importPath, this._deepHash(this.getCacheKey(inputFile)));\n    });\n\n    const allProcessedFuture = new Future;\n    async.eachLimit(inputFiles, this._maxParallelism, (inputFile, cb) => {\n      let error = null;\n      try {\n        // If this isn't a root, skip it (and definitely don't waste time\n        // looking for a cache file that won't be there).\n        if (!this.isRoot(inputFile)) {\n          return;\n        }\n\n        const absoluteImportPath = this.getAbsoluteImportPath(inputFile);\n        let cacheEntry = this._cache.get(absoluteImportPath);\n        if (! cacheEntry) {\n          cacheEntry = this._readCache(absoluteImportPath);\n          if (cacheEntry) {\n            this._cacheDebug(`Loaded ${ absoluteImportPath }`);\n          }\n        }\n        if (! (cacheEntry && this._cacheEntryValid(cacheEntry, cacheKeyMap))) {\n          cacheMisses.push(inputFile.getDisplayPath());\n\n          const compileOneFileReturn = this.compileOneFile(inputFile, allFiles);\n          if (! compileOneFileReturn) {\n            // compileOneFile should have called inputFile.error.\n            //  We don't cache failures for now.\n            return;\n          }\n          const {compileResult, referencedImportPaths} = compileOneFileReturn;\n\n          cacheEntry = {\n            compileResult,\n            cacheKeys: {\n              // Include the hashed cache key of the file itself...\n              [absoluteImportPath]: cacheKeyMap.get(absoluteImportPath)\n            }\n          };\n\n          // ... and of the other referenced files.\n          referencedImportPaths.forEach((path) => {\n            if (!cacheKeyMap.has(path)) {\n              throw Error(`Unknown absolute import path ${ path }`);\n            }\n            cacheEntry.cacheKeys[path] = cacheKeyMap.get(path);\n          });\n\n          // Save the cache entry.\n          this._cache.set(absoluteImportPath, cacheEntry);\n          this._writeCacheAsync(absoluteImportPath, cacheEntry);\n        }\n\n        this.addCompileResult(inputFile, cacheEntry.compileResult);\n      } catch (e) {\n        error = e;\n      } finally {\n        cb(error);\n      }\n    }, allProcessedFuture.resolver());\n    allProcessedFuture.wait();\n\n    if (this._cacheDebugEnabled) {\n      cacheMisses.sort();\n      this._cacheDebug(\n        `Ran (#${ ++this._callCount }) on: ${ JSON.stringify(cacheMisses) }`);\n    }\n  }\n\n  _cacheEntryValid(cacheEntry, cacheKeyMap) {\n    return Object.keys(cacheEntry.cacheKeys).every(\n      (path) => cacheEntry.cacheKeys[path] === cacheKeyMap.get(path)\n    );\n  }\n\n  // The format of a cache file on disk is the JSON-stringified cacheKeys\n  // object, a newline, followed by the CompileResult as returned from\n  // this.stringifyCompileResult.\n  _cacheFilename(absoluteImportPath) {\n    return path.join(this._diskCache,\n                     this._deepHash(absoluteImportPath) + '.cache');\n  }\n  // Loads a {compileResult, cacheKeys} cache entry from disk. Returns the whole\n  // cache entry and loads it into the in-memory cache too.\n  _readCache(absoluteImportPath) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(absoluteImportPath);\n    const raw = this._readFileOrNull(cacheFilename);\n    if (!raw) {\n      return null;\n    }\n\n    // Split on newline.\n    const newlineIndex = raw.indexOf('\\n');\n    if (newlineIndex === -1) {\n      return null;\n    }\n    const cacheKeysString = raw.substring(0, newlineIndex);\n    const compileResultString = raw.substring(newlineIndex + 1);\n\n    const cacheKeys = this._parseJSONOrNull(cacheKeysString);\n    if (!cacheKeys) {\n      return null;\n    }\n    const compileResult = this.parseCompileResult(compileResultString);\n    if (! compileResult) {\n      return null;\n    }\n\n    const cacheEntry = {compileResult, cacheKeys};\n    this._cache.set(absoluteImportPath, cacheEntry);\n    return cacheEntry;\n  }\n  _writeCacheAsync(absoluteImportPath, cacheEntry) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(absoluteImportPath);\n    const cacheContents =\n            JSON.stringify(cacheEntry.cacheKeys) + '\\n'\n            + this.stringifyCompileResult(cacheEntry.compileResult);\n    this._writeFileAsync(cacheFilename, cacheContents);\n  }\n}\n"]}