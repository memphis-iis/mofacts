{"version":3,"sources":["meteor://ðŸ’»app/packages/caching-compiler/caching-compiler.js","meteor://ðŸ’»app/packages/caching-compiler/multi-file-caching-compiler.js"],"names":["fs","Plugin","path","createHash","Npm","require","assert","Future","LRU","async","CachingCompilerBase","constructor","compilerName","defaultCacheSize","maxParallelism","_compilerName","_maxParallelism","envVarPrefix","toUpperCase","debugEnvVar","_cacheDebugEnabled","process","env","cacheSizeEnvVar","_cacheSize","_diskCache","_callCount","getCacheKey","inputFile","Error","addCompileResult","compileResult","compileResultSize","stringifyCompileResult","JSON","stringify","parseCompileResult","stringifiedCompileResult","_parseJSONOrNull","json","parse","e","SyntaxError","_cacheDebug","message","console","log","setDiskCacheDirectory","diskCache","sourceMapSize","sm","mappings","length","sourcesContent","reduce","soFar","current","_deepHash","val","hash","type","update","keys","Object","Array","isArray","sort","forEach","key","ok","digest","_writeFileAsync","filename","contents","tempFilename","Random","id","writeFileSync","renameSync","writeFile","err","rename","_readFileOrNull","readFileSync","code","CachingCompiler","_cache","max","value","compileOneFile","processFilesForTarget","inputFiles","cacheMisses","future","eachLimit","cb","error","cacheKey","get","_readCache","getDisplayPath","push","set","_writeCacheAsync","resolver","wait","_cacheFilename","test","join","cacheFilename","_readAndParseCompileResultOrNull","cacheContents","raw","MultiFileCachingCompiler","allFiles","isRoot","getAbsoluteImportPath","getPackageName","getPathInPackage","Map","cacheKeyMap","importPath","allProcessedFuture","absoluteImportPath","cacheEntry","_cacheEntryValid","compileOneFileReturn","referencedImportPaths","cacheKeys","has","every","newlineIndex","indexOf","cacheKeysString","substring","compileResultString"],"mappings":"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","file":"/packages/caching-compiler.js","sourcesContent":["const fs = Plugin.fs;\nconst path = Plugin.path;\nconst createHash = Npm.require('crypto').createHash;\nconst assert = Npm.require('assert');\nconst Future = Npm.require('fibers/future');\nconst LRU = Npm.require('lru-cache');\nconst async = Npm.require('async');\n\n// Base class for CachingCompiler and MultiFileCachingCompiler.\nCachingCompilerBase = class CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    this._compilerName = compilerName;\n    this._maxParallelism = maxParallelism;\n    const envVarPrefix = 'METEOR_' + compilerName.toUpperCase() + '_CACHE_';\n\n    const debugEnvVar = envVarPrefix + 'DEBUG';\n    this._cacheDebugEnabled = !! process.env[debugEnvVar];\n\n    const cacheSizeEnvVar = envVarPrefix + 'SIZE';\n    this._cacheSize = +process.env[cacheSizeEnvVar] || defaultCacheSize;\n\n    this._diskCache = null;\n\n    // For testing.\n    this._callCount = 0;\n  }\n\n  // Your subclass must override this method to define the key used to identify\n  // a particular version of an InputFile.\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), returns a cache key that represents\n  // it. This cache key can be any JSON value (it will be converted internally\n  // into a hash).  This should reflect any aspect of the InputFile that affects\n  // the output of `compileOneFile`. Typically you'll want to include\n  // `inputFile.getDeclaredExports()`, and perhaps\n  // `inputFile.getPathInPackage()` or `inputFile.getDeclaredExports` if\n  // `compileOneFile` pays attention to them.\n  //\n  // Note that for MultiFileCachingCompiler, your cache key doesn't need to\n  // include the file's path, because that is automatically taken into account\n  // by the implementation. CachingCompiler subclasses can choose whether or not\n  // to include the file's path in the cache key.\n  getCacheKey(inputFile) {\n    throw Error('CachingCompiler subclass should implement getCacheKey!');\n  }\n\n  // Your subclass must override this method to define how a CompileResult\n  // translates into adding assets to the bundle.\n  //\n  // This method is given an InputFile (the data type passed to\n  // processFilesForTarget as part of the Plugin.registerCompiler API) and a\n  // CompileResult (either returned directly from compileOneFile or read from\n  // the cache).  It should call methods like `inputFile.addJavaScript`\n  // and `inputFile.error`.\n  addCompileResult(inputFile, compileResult) {\n    throw Error('CachingCompiler subclass should implement addCompileResult!');\n  }\n\n  // Your subclass must override this method to define the size of a\n  // CompilerResult (used by the in-memory cache to limit the total amount of\n  // data cached).\n  compileResultSize(compileResult) {\n    throw Error('CachingCompiler subclass should implement compileResultSize!');\n  }\n\n  // Your subclass may override this method to define an alternate way of\n  // stringifying CompilerResults.  Takes a CompileResult and returns a string.\n  stringifyCompileResult(compileResult) {\n    return JSON.stringify(compileResult);\n  }\n  // Your subclass may override this method to define an alternate way of\n  // parsing CompilerResults from string.  Takes a string and returns a\n  // CompileResult.  If the string doesn't represent a valid CompileResult, you\n  // may want to return null instead of throwing, which will make\n  // CachingCompiler ignore the cache.\n  parseCompileResult(stringifiedCompileResult) {\n    return this._parseJSONOrNull(stringifiedCompileResult);\n  }\n  _parseJSONOrNull(json) {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      if (e instanceof SyntaxError)\n        return null;\n      throw e;\n    }\n  }\n\n  _cacheDebug(message) {\n    if (!this._cacheDebugEnabled)\n      return;\n    console.log(`CACHE(${ this._compilerName }): ${ message }`);\n  }\n\n  setDiskCacheDirectory(diskCache) {\n    if (this._diskCache)\n      throw Error('setDiskCacheDirectory called twice?');\n    this._diskCache = diskCache;\n  }\n\n  // Since so many compilers will need to calculate the size of a SourceMap in\n  // their compileResultSize, this method is provided.\n  sourceMapSize(sm) {\n    if (! sm) return 0;\n    // sum the length of sources and the mappings, the size of\n    // metadata is ignored, but it is not a big deal\n    return sm.mappings.length\n      + (sm.sourcesContent || []).reduce(function (soFar, current) {\n        return soFar + (current ? current.length : 0);\n      }, 0);\n  }\n\n  // Borrowed from another MIT-licensed project that benjamn wrote:\n  // https://github.com/reactjs/commoner/blob/235d54a12c/lib/util.js#L136-L168\n  _deepHash(val) {\n    const hash = createHash('sha1');\n    let type = typeof val;\n\n    if (val === null) {\n      type = 'null';\n    }\n    hash.update(type + '\\0');\n\n    switch (type) {\n    case 'object':\n      const keys = Object.keys(val);\n\n      // Array keys will already be sorted.\n      if (! Array.isArray(val)) {\n        keys.sort();\n      }\n\n      keys.forEach((key) => {\n        if (typeof val[key] === 'function') {\n          // Silently ignore nested methods, but nevertheless complain below\n          // if the root value is a function.\n          return;\n        }\n\n        hash.update(key + '\\0').update(this._deepHash(val[key]));\n      });\n\n      break;\n\n    case 'function':\n      assert.ok(false, 'cannot hash function objects');\n      break;\n\n    default:\n      hash.update('' + val);\n      break;\n    }\n\n    return hash.digest('hex');\n  }\n\n  // We want to write the file atomically. But we also don't want to block\n  // processing on the file write.\n  _writeFileAsync(filename, contents) {\n    const tempFilename = filename + '.tmp.' + Random.id();\n    if (this._cacheDebugEnabled) {\n      // Write cache file synchronously when cache debugging enabled.\n      try {\n        fs.writeFileSync(tempFilename, contents);\n        fs.renameSync(tempFilename, filename);\n      } catch (e) {\n        // ignore errors, it's just a cache\n      }\n    } else {\n      fs.writeFile(tempFilename, contents, err => {\n        // ignore errors, it's just a cache\n        if (! err) {\n          fs.rename(tempFilename, filename, err => {});\n        }\n      });\n    }\n  }\n\n  // Helper function. Returns the body of the file as a string, or null if it\n  // doesn't exist.\n  _readFileOrNull(filename) {\n    try {\n      return fs.readFileSync(filename, 'utf8');\n    } catch (e) {\n      if (e && e.code === 'ENOENT')\n        return null;\n      throw e;\n    }\n  }\n}\n\n// CachingCompiler is a class designed to be used with Plugin.registerCompiler\n// which implements in-memory and on-disk caches for the files that it\n// processes.  You should subclass CachingCompiler and define the following\n// methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.\n//\n// CachingCompiler assumes that files are processed independently of each other;\n// there is no 'import' directive allowing one file to reference another.  That\n// is, editing one file should only require that file to be rebuilt, not other\n// files.\n//\n// The data that is cached for each file is of a type that is (implicitly)\n// defined by your subclass. CachingCompiler refers to this type as\n// `CompileResult`, but this isn't a single type: it's up to your subclass to\n// decide what type of data this is.  You should document what your subclass's\n// CompileResult type is.\n//\n// Your subclass's compiler should call the superclass compiler specifying the\n// compiler name (used to generate environment variables for debugging and\n// tweaking in-memory cache size) and the default cache size.\n//\n// By default, CachingCompiler processes each file in \"parallel\". That is, if it\n// needs to yield to read from the disk cache, or if getCacheKey,\n// compileOneFile, or addCompileResult yields, it will start processing the next\n// few files. To set how many files can be processed in parallel (including\n// setting it to 1 if your subclass doesn't support any parallelism), pass the\n// maxParallelism option to the superclass constructor.\n//\n// For example (using ES2015 via the ecmascript package):\n//\n//   class AwesomeCompiler extends CachingCompiler {\n//     constructor() {\n//       super({\n//         compilerName: 'awesome',\n//         defaultCacheSize: 1024*1024*10,\n//       });\n//     }\n//     // ... define the other methods\n//   }\n//   Plugin.registerCompile({\n//     extensions: ['awesome'],\n//   }, () => new AwesomeCompiler());\n//\n// XXX maybe compileResultSize and stringifyCompileResult should just be methods\n// on CompileResult? Sort of hard to do that with parseCompileResult.\nCachingCompiler = class CachingCompiler extends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from a hashed cache key to a compileResult.\n    this._cache = new LRU({\n      max: this._cacheSize,\n      length: (value) => this.compileResultSize(value),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), compiles the file and returns a\n  // CompileResult (the cacheable data type specific to your subclass).\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile) {\n    throw Error('CachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API. If\n  // you have processing you want to perform at the beginning or end of a\n  // processing phase, you may want to override this method and call the\n  // superclass implementation from within your method.\n  processFilesForTarget(inputFiles) {\n    const cacheMisses = [];\n\n    const future = new Future;\n    async.eachLimit(inputFiles, this._maxParallelism, (inputFile, cb) => {\n      let error = null;\n      try {\n        const cacheKey = this._deepHash(this.getCacheKey(inputFile));\n        let compileResult = this._cache.get(cacheKey);\n\n        if (! compileResult) {\n          compileResult = this._readCache(cacheKey);\n          if (compileResult) {\n            this._cacheDebug(`Loaded ${ inputFile.getDisplayPath() }`);\n          }\n        }\n\n        if (! compileResult) {\n          cacheMisses.push(inputFile.getDisplayPath());\n          compileResult = this.compileOneFile(inputFile);\n\n          if (! compileResult) {\n            // compileOneFile should have called inputFile.error.\n            //  We don't cache failures for now.\n            return;\n          }\n\n          // Save what we've compiled.\n          this._cache.set(cacheKey, compileResult);\n          this._writeCacheAsync(cacheKey, compileResult);\n        }\n\n        this.addCompileResult(inputFile, compileResult);\n      } catch (e) {\n        error = e;\n      } finally {\n        cb(error);\n      }\n    }, future.resolver());\n    future.wait();\n\n    if (this._cacheDebugEnabled) {\n      cacheMisses.sort();\n      this._cacheDebug(\n        `Ran (#${ ++this._callCount }) on: ${ JSON.stringify(cacheMisses) }`);\n    }\n  }\n\n  _cacheFilename(cacheKey) {\n    // We want cacheKeys to be hex so that they work on any FS and never end in\n    // .cache.\n    if (!/^[a-f0-9]+$/.test(cacheKey)) {\n      throw Error('bad cacheKey: ' + cacheKey);\n    }\n    return path.join(this._diskCache, cacheKey + '.cache');\n  }\n  // Load a cache entry from disk. Returns the compileResult object\n  // and loads it into the in-memory cache too.\n  _readCache(cacheKey) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const compileResult = this._readAndParseCompileResultOrNull(cacheFilename);\n    if (! compileResult) {\n      return null;\n    }\n    this._cache.set(cacheKey, compileResult);\n    return compileResult;\n  }\n  _writeCacheAsync(cacheKey, compileResult) {\n    if (! this._diskCache)\n      return;\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const cacheContents = this.stringifyCompileResult(compileResult);\n    this._writeFileAsync(cacheFilename, cacheContents);\n  }\n\n  // Returns null if the file does not exist or can't be parsed; otherwise\n  // returns the parsed compileResult in the file.\n  _readAndParseCompileResultOrNull(filename) {\n    const raw = this._readFileOrNull(filename);\n    return this.parseCompileResult(raw);\n  }\n}\n","const path = Plugin.path;\nconst Future = Npm.require('fibers/future');\nconst LRU = Npm.require('lru-cache');\nconst async = Npm.require('async');\n\n// MultiFileCachingCompiler is like CachingCompiler, but for implementing\n// languages which allow files to reference each other, such as CSS\n// preprocessors with `@import` directives.\n//\n// Like CachingCompiler, you should subclass MultiFileCachingCompiler and define\n// the following methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.  compileOneFile gets an additional allFiles argument and\n// returns an array of referenced import paths in addition to the CompileResult.\n// You may also override isRoot and getAbsoluteImportPath to customize\n// MultiFileCachingCompiler further.\nMultiFileCachingCompiler = class MultiFileCachingCompiler\nextends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from absolute import path to { compileResult, cacheKeys }, where\n    // cacheKeys is an object mapping from absolute import path to hashed\n    // cacheKey for each file referenced by this file (including itself).\n    this._cache = new LRU({\n      max: this._cacheSize,\n      // We ignore the size of cacheKeys here.\n      length: (value) => this.compileResultSize(value.compileResult),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Arguments:\n  //   - inputFile is the InputFile to process\n  //   - allFiles is a a Map mapping from absolute import path to InputFile of\n  //     all files being processed in the target\n  // Returns an object with keys:\n  //   - compileResult: the CompileResult (the cacheable data type specific to\n  //     your subclass).\n  //   - referencedImportPaths: an array of absolute import paths of files\n  //     which were refererenced by the current file.  The current file\n  //     is included implicitly.\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile, allFiles) {\n    throw Error(\n      'MultiFileCachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // Your subclass may override this to declare that a file is not a \"root\" ---\n  // ie, it can be included from other files but is not processed on its own. In\n  // this case, MultiFileCachingCompiler won't waste time trying to look for a\n  // cache for its compilation on disk.\n  isRoot(inputFile) {\n    return true;\n  }\n\n  // Returns the absolute import path for an InputFile. By default, this is a\n  // path is a path of the form \"{package}/path/to/file\" for files in packages\n  // and \"{}/path/to/file\" for files in apps. Your subclass may override and/or\n  // call this method.\n  getAbsoluteImportPath(inputFile) {\n    if (inputFile.getPackageName() === null) {\n      return '{}/' + inputFile.getPathInPackage();\n    }\n    return '{' + inputFile.getPackageName() + '}/'\n      + inputFile.getPathInPackage();\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API.\n  processFilesForTarget(inputFiles) {\n    const allFiles = new Map;\n    const cacheKeyMap = new Map;\n    const cacheMisses = [];\n\n    inputFiles.forEach((inputFile) => {\n      const importPath = this.getAbsoluteImportPath(inputFile);\n      allFiles.set(importPath, inputFile);\n      cacheKeyMap.set(importPath, this._deepHash(this.getCacheKey(inputFile)));\n    });\n\n    const allProcessedFuture = new Future;\n    async.eachLimit(inputFiles, this._maxParallelism, (inputFile, cb) => {\n      let error = null;\n      try {\n        // If this isn't a root, skip it (and definitely don't waste time\n        // looking for a cache file that won't be there).\n        if (!this.isRoot(inputFile)) {\n          return;\n        }\n\n        const absoluteImportPath = this.getAbsoluteImportPath(inputFile);\n        let cacheEntry = this._cache.get(absoluteImportPath);\n        if (! cacheEntry) {\n          cacheEntry = this._readCache(absoluteImportPath);\n          if (cacheEntry) {\n            this._cacheDebug(`Loaded ${ absoluteImportPath }`);\n          }\n        }\n        if (! (cacheEntry && this._cacheEntryValid(cacheEntry, cacheKeyMap))) {\n          cacheMisses.push(inputFile.getDisplayPath());\n\n          const compileOneFileReturn = this.compileOneFile(inputFile, allFiles);\n          if (! compileOneFileReturn) {\n            // compileOneFile should have called inputFile.error.\n            //  We don't cache failures for now.\n            return;\n          }\n          const {compileResult, referencedImportPaths} = compileOneFileReturn;\n\n          cacheEntry = {\n            compileResult,\n            cacheKeys: {\n              // Include the hashed cache key of the file itself...\n              [absoluteImportPath]: cacheKeyMap.get(absoluteImportPath)\n            }\n          };\n\n          // ... and of the other referenced files.\n          referencedImportPaths.forEach((path) => {\n            if (!cacheKeyMap.has(path)) {\n              throw Error(`Unknown absolute import path ${ path }`);\n            }\n            cacheEntry.cacheKeys[path] = cacheKeyMap.get(path);\n          });\n\n          // Save the cache entry.\n          this._cache.set(absoluteImportPath, cacheEntry);\n          this._writeCacheAsync(absoluteImportPath, cacheEntry);\n        }\n\n        this.addCompileResult(inputFile, cacheEntry.compileResult);\n      } catch (e) {\n        error = e;\n      } finally {\n        cb(error);\n      }\n    }, allProcessedFuture.resolver());\n    allProcessedFuture.wait();\n\n    if (this._cacheDebugEnabled) {\n      cacheMisses.sort();\n      this._cacheDebug(\n        `Ran (#${ ++this._callCount }) on: ${ JSON.stringify(cacheMisses) }`);\n    }\n  }\n\n  _cacheEntryValid(cacheEntry, cacheKeyMap) {\n    return Object.keys(cacheEntry.cacheKeys).every(\n      (path) => cacheEntry.cacheKeys[path] === cacheKeyMap.get(path)\n    );\n  }\n\n  // The format of a cache file on disk is the JSON-stringified cacheKeys\n  // object, a newline, followed by the CompileResult as returned from\n  // this.stringifyCompileResult.\n  _cacheFilename(absoluteImportPath) {\n    return path.join(this._diskCache,\n                     this._deepHash(absoluteImportPath) + '.cache');\n  }\n  // Loads a {compileResult, cacheKeys} cache entry from disk. Returns the whole\n  // cache entry and loads it into the in-memory cache too.\n  _readCache(absoluteImportPath) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(absoluteImportPath);\n    const raw = this._readFileOrNull(cacheFilename);\n    if (!raw) {\n      return null;\n    }\n\n    // Split on newline.\n    const newlineIndex = raw.indexOf('\\n');\n    if (newlineIndex === -1) {\n      return null;\n    }\n    const cacheKeysString = raw.substring(0, newlineIndex);\n    const compileResultString = raw.substring(newlineIndex + 1);\n\n    const cacheKeys = this._parseJSONOrNull(cacheKeysString);\n    if (!cacheKeys) {\n      return null;\n    }\n    const compileResult = this.parseCompileResult(compileResultString);\n    if (! compileResult) {\n      return null;\n    }\n\n    const cacheEntry = {compileResult, cacheKeys};\n    this._cache.set(absoluteImportPath, cacheEntry);\n    return cacheEntry;\n  }\n  _writeCacheAsync(absoluteImportPath, cacheEntry) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(absoluteImportPath);\n    const cacheContents =\n            JSON.stringify(cacheEntry.cacheKeys) + '\\n'\n            + this.stringifyCompileResult(cacheEntry.compileResult);\n    this._writeFileAsync(cacheFilename, cacheContents);\n  }\n}\n"]}