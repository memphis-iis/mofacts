{"version":3,"sources":["meteor://ðŸ’»app/packages/caching-compiler/caching-compiler.js","meteor://ðŸ’»app/packages/caching-compiler/multi-file-caching-compiler.js"],"names":["fs","Plugin","path","createHash","Npm","require","assert","LRU","CachingCompilerBase","constructor","compilerName","defaultCacheSize","maxParallelism","_compilerName","_maxParallelism","compilerNameForEnvar","toUpperCase","replace","envVarPrefix","debugEnvVar","_cacheDebugEnabled","process","env","cacheSizeEnvVar","_cacheSize","_diskCache","_callCount","_afterLinkCallbacks","getCacheKey","inputFile","Error","addCompileResult","compileResult","compileResultSize","stringifyCompileResult","JSON","stringify","parseCompileResult","stringifiedCompileResult","_parseJSONOrNull","json","parse","e","SyntaxError","_cacheDebug","message","console","log","setDiskCacheDirectory","diskCache","sourceMapSize","sm","mappings","length","sourcesContent","reduce","soFar","current","afterLink","splice","forEach","callback","_deepHash","val","hash","type","update","keys","Object","Array","isArray","sort","key","ok","digest","_writeFileAsync","filename","contents","tempFilename","Random","id","writeFileSync","renameSync","writeFile","writeError","renameError","_readFileOrNull","readFileSync","code","CachingCompiler","_cache","max","value","compileOneFile","processFilesForTarget","inputFiles","cacheMisses","arches","create","getArch","getResult","cacheKey","get","_readCache","getDisplayPath","push","Promise","await","set","_writeCacheAsync","compileOneFileLater","supportsLazyCompilation","result","_cacheFilename","test","join","cacheFilename","_readAndParseCompileResultOrNull","cacheContents","raw","MultiFileCachingCompiler","allFiles","isRoot","getAbsoluteImportPath","getPackageName","getPathInPackage","Map","cacheKeyMap","importPath","_getCacheKeyWithPath","absoluteImportPath","cacheEntry","_cacheEntryValid","compileOneFileReturn","referencedImportPaths","cacheKeys","has","getFileOptions","lazy","every","newlineIndex","indexOf","cacheKeysString","substring","compileResultString"],"mappings":"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","file":"/packages/caching-compiler.js","sourcesContent":["const fs = Plugin.fs;\nconst path = Plugin.path;\nconst createHash = Npm.require('crypto').createHash;\nconst assert = Npm.require('assert');\nconst LRU = Npm.require('lru-cache');\n\n// Base class for CachingCompiler and MultiFileCachingCompiler.\nCachingCompilerBase = class CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    this._compilerName = compilerName;\n    this._maxParallelism = maxParallelism;\n    const compilerNameForEnvar = compilerName.toUpperCase()\n      .replace('/-/g', '_').replace(/[^A-Z0-9_]/g, '');\n    const envVarPrefix = 'METEOR_' + compilerNameForEnvar + '_CACHE_';\n\n    const debugEnvVar = envVarPrefix + 'DEBUG';\n    this._cacheDebugEnabled = !! process.env[debugEnvVar];\n\n    const cacheSizeEnvVar = envVarPrefix + 'SIZE';\n    this._cacheSize = +process.env[cacheSizeEnvVar] || defaultCacheSize;\n\n    this._diskCache = null;\n\n    // For testing.\n    this._callCount = 0;\n\n    // Callbacks that will be called after the linker is done processing\n    // files, after all lazy compilation has finished.\n    this._afterLinkCallbacks = [];\n  }\n\n  // Your subclass must override this method to define the key used to identify\n  // a particular version of an InputFile.\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), returns a cache key that represents\n  // it. This cache key can be any JSON value (it will be converted internally\n  // into a hash).  This should reflect any aspect of the InputFile that affects\n  // the output of `compileOneFile`. Typically you'll want to include\n  // `inputFile.getDeclaredExports()`, and perhaps\n  // `inputFile.getPathInPackage()` or `inputFile.getDeclaredExports` if\n  // `compileOneFile` pays attention to them.\n  //\n  // Note that for MultiFileCachingCompiler, your cache key doesn't need to\n  // include the file's path, because that is automatically taken into account\n  // by the implementation. CachingCompiler subclasses can choose whether or not\n  // to include the file's path in the cache key.\n  getCacheKey(inputFile) {\n    throw Error('CachingCompiler subclass should implement getCacheKey!');\n  }\n\n  // Your subclass must override this method to define how a CompileResult\n  // translates into adding assets to the bundle.\n  //\n  // This method is given an InputFile (the data type passed to\n  // processFilesForTarget as part of the Plugin.registerCompiler API) and a\n  // CompileResult (either returned directly from compileOneFile or read from\n  // the cache).  It should call methods like `inputFile.addJavaScript`\n  // and `inputFile.error`.\n  addCompileResult(inputFile, compileResult) {\n    throw Error('CachingCompiler subclass should implement addCompileResult!');\n  }\n\n  // Your subclass must override this method to define the size of a\n  // CompilerResult (used by the in-memory cache to limit the total amount of\n  // data cached).\n  compileResultSize(compileResult) {\n    throw Error('CachingCompiler subclass should implement compileResultSize!');\n  }\n\n  // Your subclass may override this method to define an alternate way of\n  // stringifying CompilerResults.  Takes a CompileResult and returns a string.\n  stringifyCompileResult(compileResult) {\n    return JSON.stringify(compileResult);\n  }\n  // Your subclass may override this method to define an alternate way of\n  // parsing CompilerResults from string.  Takes a string and returns a\n  // CompileResult.  If the string doesn't represent a valid CompileResult, you\n  // may want to return null instead of throwing, which will make\n  // CachingCompiler ignore the cache.\n  parseCompileResult(stringifiedCompileResult) {\n    return this._parseJSONOrNull(stringifiedCompileResult);\n  }\n  _parseJSONOrNull(json) {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      if (e instanceof SyntaxError)\n        return null;\n      throw e;\n    }\n  }\n\n  _cacheDebug(message) {\n    if (!this._cacheDebugEnabled)\n      return;\n    console.log(`CACHE(${ this._compilerName }): ${ message }`);\n  }\n\n  setDiskCacheDirectory(diskCache) {\n    if (this._diskCache)\n      throw Error('setDiskCacheDirectory called twice?');\n    this._diskCache = diskCache;\n  }\n\n  // Since so many compilers will need to calculate the size of a SourceMap in\n  // their compileResultSize, this method is provided.\n  sourceMapSize(sm) {\n    if (! sm) return 0;\n    // sum the length of sources and the mappings, the size of\n    // metadata is ignored, but it is not a big deal\n    return sm.mappings.length\n      + (sm.sourcesContent || []).reduce(function (soFar, current) {\n        return soFar + (current ? current.length : 0);\n      }, 0);\n  }\n\n  // Called by the compiler plugins system after all linking and lazy\n  // compilation has finished.\n  afterLink() {\n    this._afterLinkCallbacks.splice(0).forEach(callback => {\n      callback();\n    });\n  }\n\n  // Borrowed from another MIT-licensed project that benjamn wrote:\n  // https://github.com/reactjs/commoner/blob/235d54a12c/lib/util.js#L136-L168\n  _deepHash(val) {\n    const hash = createHash('sha1');\n    let type = typeof val;\n\n    if (val === null) {\n      type = 'null';\n    }\n    hash.update(type + '\\0');\n\n    switch (type) {\n    case 'object':\n      const keys = Object.keys(val);\n\n      // Array keys will already be sorted.\n      if (! Array.isArray(val)) {\n        keys.sort();\n      }\n\n      keys.forEach((key) => {\n        if (typeof val[key] === 'function') {\n          // Silently ignore nested methods, but nevertheless complain below\n          // if the root value is a function.\n          return;\n        }\n\n        hash.update(key + '\\0').update(this._deepHash(val[key]));\n      });\n\n      break;\n\n    case 'function':\n      assert.ok(false, 'cannot hash function objects');\n      break;\n\n    default:\n      hash.update('' + val);\n      break;\n    }\n\n    return hash.digest('hex');\n  }\n\n  // We want to write the file atomically. But we also don't want to block\n  // processing on the file write.\n  _writeFileAsync(filename, contents) {\n    const tempFilename = filename + '.tmp.' + Random.id();\n    if (this._cacheDebugEnabled) {\n      // Write cache file synchronously when cache debugging enabled.\n      try {\n        fs.writeFileSync(tempFilename, contents);\n        fs.renameSync(tempFilename, filename);\n      } catch (e) {\n        // ignore errors, it's just a cache\n      }\n    } else {\n      fs.writeFile(tempFilename, contents, writeError => {\n        if (writeError) return;\n        try {\n          fs.renameSync(tempFilename, filename);\n        } catch (renameError) {\n          // ignore errors, it's just a cache\n        }\n      });\n    }\n  }\n\n  // Helper function. Returns the body of the file as a string, or null if it\n  // doesn't exist.\n  _readFileOrNull(filename) {\n    try {\n      return fs.readFileSync(filename, 'utf8');\n    } catch (e) {\n      if (e && e.code === 'ENOENT')\n        return null;\n      throw e;\n    }\n  }\n}\n\n// CachingCompiler is a class designed to be used with Plugin.registerCompiler\n// which implements in-memory and on-disk caches for the files that it\n// processes.  You should subclass CachingCompiler and define the following\n// methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.\n//\n// CachingCompiler assumes that files are processed independently of each other;\n// there is no 'import' directive allowing one file to reference another.  That\n// is, editing one file should only require that file to be rebuilt, not other\n// files.\n//\n// The data that is cached for each file is of a type that is (implicitly)\n// defined by your subclass. CachingCompiler refers to this type as\n// `CompileResult`, but this isn't a single type: it's up to your subclass to\n// decide what type of data this is.  You should document what your subclass's\n// CompileResult type is.\n//\n// Your subclass's compiler should call the superclass compiler specifying the\n// compiler name (used to generate environment variables for debugging and\n// tweaking in-memory cache size) and the default cache size.\n//\n// By default, CachingCompiler processes each file in \"parallel\". That is, if it\n// needs to yield to read from the disk cache, or if getCacheKey,\n// compileOneFile, or addCompileResult yields, it will start processing the next\n// few files. To set how many files can be processed in parallel (including\n// setting it to 1 if your subclass doesn't support any parallelism), pass the\n// maxParallelism option to the superclass constructor.\n//\n// For example (using ES2015 via the ecmascript package):\n//\n//   class AwesomeCompiler extends CachingCompiler {\n//     constructor() {\n//       super({\n//         compilerName: 'awesome',\n//         defaultCacheSize: 1024*1024*10,\n//       });\n//     }\n//     // ... define the other methods\n//   }\n//   Plugin.registerCompile({\n//     extensions: ['awesome'],\n//   }, () => new AwesomeCompiler());\n//\n// XXX maybe compileResultSize and stringifyCompileResult should just be methods\n// on CompileResult? Sort of hard to do that with parseCompileResult.\nCachingCompiler = class CachingCompiler extends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from a hashed cache key to a compileResult.\n    this._cache = new LRU({\n      max: this._cacheSize,\n      length: (value) => this.compileResultSize(value),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), compiles the file and returns a\n  // CompileResult (the cacheable data type specific to your subclass).\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile) {\n    throw Error('CachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API. If\n  // you have processing you want to perform at the beginning or end of a\n  // processing phase, you may want to override this method and call the\n  // superclass implementation from within your method.\n  async processFilesForTarget(inputFiles) {\n    const cacheMisses = [];\n    const arches = this._cacheDebugEnabled && Object.create(null);\n\n    inputFiles.forEach(inputFile => {\n      if (arches) {\n        arches[inputFile.getArch()] = 1;\n      }\n\n      const getResult = () => {\n        const cacheKey = this._deepHash(this.getCacheKey(inputFile));\n        let compileResult = this._cache.get(cacheKey);\n\n        if (! compileResult) {\n          compileResult = this._readCache(cacheKey);\n          if (compileResult) {\n            this._cacheDebug(`Loaded ${ inputFile.getDisplayPath() }`);\n          }\n        }\n\n        if (! compileResult) {\n          cacheMisses.push(inputFile.getDisplayPath());\n          compileResult = Promise.await(this.compileOneFile(inputFile));\n\n          if (! compileResult) {\n            // compileOneFile should have called inputFile.error.\n            //  We don't cache failures for now.\n            return;\n          }\n\n          // Save what we've compiled.\n          this._cache.set(cacheKey, compileResult);\n          this._writeCacheAsync(cacheKey, compileResult);\n        }\n\n        return compileResult;\n      };\n\n      if (this.compileOneFileLater &&\n          inputFile.supportsLazyCompilation) {\n        this.compileOneFileLater(inputFile, getResult);\n      } else {\n        const result = getResult();\n        if (result) {\n          this.addCompileResult(inputFile, result);\n        }\n      }\n    });\n\n    if (this._cacheDebugEnabled) {\n      this._afterLinkCallbacks.push(() => {\n        cacheMisses.sort();\n\n        this._cacheDebug(\n          `Ran (#${\n            ++this._callCount\n          }) on: ${\n            JSON.stringify(cacheMisses)\n          } ${\n            JSON.stringify(Object.keys(arches).sort())\n          }`\n        );\n      });\n    }\n  }\n\n  _cacheFilename(cacheKey) {\n    // We want cacheKeys to be hex so that they work on any FS and never end in\n    // .cache.\n    if (!/^[a-f0-9]+$/.test(cacheKey)) {\n      throw Error('bad cacheKey: ' + cacheKey);\n    }\n    return path.join(this._diskCache, cacheKey + '.cache');\n  }\n  // Load a cache entry from disk. Returns the compileResult object\n  // and loads it into the in-memory cache too.\n  _readCache(cacheKey) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const compileResult = this._readAndParseCompileResultOrNull(cacheFilename);\n    if (! compileResult) {\n      return null;\n    }\n    this._cache.set(cacheKey, compileResult);\n    return compileResult;\n  }\n  _writeCacheAsync(cacheKey, compileResult) {\n    if (! this._diskCache)\n      return;\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const cacheContents = this.stringifyCompileResult(compileResult);\n    this._writeFileAsync(cacheFilename, cacheContents);\n  }\n\n  // Returns null if the file does not exist or can't be parsed; otherwise\n  // returns the parsed compileResult in the file.\n  _readAndParseCompileResultOrNull(filename) {\n    const raw = this._readFileOrNull(filename);\n    return this.parseCompileResult(raw);\n  }\n}\n","const path = Plugin.path;\nconst LRU = Npm.require('lru-cache');\n\n// MultiFileCachingCompiler is like CachingCompiler, but for implementing\n// languages which allow files to reference each other, such as CSS\n// preprocessors with `@import` directives.\n//\n// Like CachingCompiler, you should subclass MultiFileCachingCompiler and define\n// the following methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.  compileOneFile gets an additional allFiles argument and\n// returns an array of referenced import paths in addition to the CompileResult.\n// You may also override isRoot and getAbsoluteImportPath to customize\n// MultiFileCachingCompiler further.\nMultiFileCachingCompiler = class MultiFileCachingCompiler\nextends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from cache key to { compileResult, cacheKeys }, where\n    // cacheKeys is an object mapping from absolute import path to hashed\n    // cacheKey for each file referenced by this file (including itself).\n    this._cache = new LRU({\n      max: this._cacheSize,\n      // We ignore the size of cacheKeys here.\n      length: (value) => this.compileResultSize(value.compileResult),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Arguments:\n  //   - inputFile is the InputFile to process\n  //   - allFiles is a a Map mapping from absolute import path to InputFile of\n  //     all files being processed in the target\n  // Returns an object with keys:\n  //   - compileResult: the CompileResult (the cacheable data type specific to\n  //     your subclass).\n  //   - referencedImportPaths: an array of absolute import paths of files\n  //     which were refererenced by the current file.  The current file\n  //     is included implicitly.\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile, allFiles) {\n    throw Error(\n      'MultiFileCachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // Your subclass may override this to declare that a file is not a \"root\" ---\n  // ie, it can be included from other files but is not processed on its own. In\n  // this case, MultiFileCachingCompiler won't waste time trying to look for a\n  // cache for its compilation on disk.\n  isRoot(inputFile) {\n    return true;\n  }\n\n  // Returns the absolute import path for an InputFile. By default, this is a\n  // path is a path of the form \"{package}/path/to/file\" for files in packages\n  // and \"{}/path/to/file\" for files in apps. Your subclass may override and/or\n  // call this method.\n  getAbsoluteImportPath(inputFile) {\n    if (inputFile.getPackageName() === null) {\n      return '{}/' + inputFile.getPathInPackage();\n    }\n    return '{' + inputFile.getPackageName() + '}/'\n      + inputFile.getPathInPackage();\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API.\n  async processFilesForTarget(inputFiles) {\n    const allFiles = new Map;\n    const cacheKeyMap = new Map;\n    const cacheMisses = [];\n    const arches = this._cacheDebugEnabled && Object.create(null);\n\n    inputFiles.forEach((inputFile) => {\n      const importPath = this.getAbsoluteImportPath(inputFile);\n      allFiles.set(importPath, inputFile);\n      cacheKeyMap.set(importPath, this._getCacheKeyWithPath(inputFile));\n    });\n\n    inputFiles.forEach(inputFile => {\n      if (arches) {\n        arches[inputFile.getArch()] = 1;\n      }\n\n      const getResult = () => {\n        const absoluteImportPath = this.getAbsoluteImportPath(inputFile);\n        const cacheKey = cacheKeyMap.get(absoluteImportPath);\n        let cacheEntry = this._cache.get(cacheKey);\n        if (! cacheEntry) {\n          cacheEntry = this._readCache(cacheKey);\n          if (cacheEntry) {\n            this._cacheDebug(`Loaded ${ absoluteImportPath }`);\n          }\n        }\n\n        if (! (cacheEntry && this._cacheEntryValid(cacheEntry, cacheKeyMap))) {\n          cacheMisses.push(inputFile.getDisplayPath());\n\n          const compileOneFileReturn =\n            Promise.await(this.compileOneFile(inputFile, allFiles));\n\n          if (! compileOneFileReturn) {\n            // compileOneFile should have called inputFile.error.\n            // We don't cache failures for now.\n            return;\n          }\n\n          const {\n            compileResult,\n            referencedImportPaths,\n          } = compileOneFileReturn;\n\n          cacheEntry = {\n            compileResult,\n            cacheKeys: {\n              // Include the hashed cache key of the file itself...\n              [absoluteImportPath]: cacheKeyMap.get(absoluteImportPath)\n            }\n          };\n\n          // ... and of the other referenced files.\n          referencedImportPaths.forEach((path) => {\n            if (!cacheKeyMap.has(path)) {\n              throw Error(`Unknown absolute import path ${ path }`);\n            }\n            cacheEntry.cacheKeys[path] = cacheKeyMap.get(path);\n          });\n\n          // Save the cache entry.\n          this._cache.set(cacheKey, cacheEntry);\n          this._writeCacheAsync(cacheKey, cacheEntry);\n        }\n\n        return cacheEntry.compileResult;\n      };\n\n      if (this.compileOneFileLater &&\n          inputFile.supportsLazyCompilation) {\n        if (! this.isRoot(inputFile)) {\n          // If this inputFile is definitely not a root, then it must be\n          // lazy, and this is our last chance to mark it as such, so that\n          // the rest of the compiler plugin system can avoid worrying\n          // about the MultiFileCachingCompiler-specific concept of a\n          // \"root.\" If this.isRoot(inputFile) returns true instead, that\n          // classification may not be trustworthy, since returning true\n          // used to be the only way to get the file to be compiled, so\n          // that it could be imported later by a JS module. Now that\n          // files can be compiled on-demand, it's safe to pass all files\n          // that might be roots to this.compileOneFileLater.\n          inputFile.getFileOptions().lazy = true;\n        }\n        this.compileOneFileLater(inputFile, getResult);\n      } else if (this.isRoot(inputFile)) {\n        const result = getResult();\n        if (result) {\n          this.addCompileResult(inputFile, result);\n        }\n      }\n    });\n\n    if (this._cacheDebugEnabled) {\n      this._afterLinkCallbacks.push(() => {\n        cacheMisses.sort();\n\n        this._cacheDebug(\n          `Ran (#${\n            ++this._callCount\n          }) on: ${\n            JSON.stringify(cacheMisses)\n          } ${\n            JSON.stringify(Object.keys(arches).sort())\n          }`\n        );\n      });\n    }\n  }\n\n  // Returns a hash that incorporates both this.getCacheKey(inputFile) and\n  // this.getAbsoluteImportPath(inputFile), since the file path might be\n  // relevant to the compiled output when using MultiFileCachingCompiler.\n  _getCacheKeyWithPath(inputFile) {\n    return this._deepHash([\n      this.getAbsoluteImportPath(inputFile),\n      this.getCacheKey(inputFile),\n    ]);\n  }\n\n  _cacheEntryValid(cacheEntry, cacheKeyMap) {\n    return Object.keys(cacheEntry.cacheKeys).every(\n      (path) => cacheEntry.cacheKeys[path] === cacheKeyMap.get(path)\n    );\n  }\n\n  // The format of a cache file on disk is the JSON-stringified cacheKeys\n  // object, a newline, followed by the CompileResult as returned from\n  // this.stringifyCompileResult.\n  _cacheFilename(cacheKey) {\n    return path.join(this._diskCache, cacheKey + \".cache\");\n  }\n\n  // Loads a {compileResult, cacheKeys} cache entry from disk. Returns the whole\n  // cache entry and loads it into the in-memory cache too.\n  _readCache(cacheKey) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const raw = this._readFileOrNull(cacheFilename);\n    if (!raw) {\n      return null;\n    }\n\n    // Split on newline.\n    const newlineIndex = raw.indexOf('\\n');\n    if (newlineIndex === -1) {\n      return null;\n    }\n    const cacheKeysString = raw.substring(0, newlineIndex);\n    const compileResultString = raw.substring(newlineIndex + 1);\n\n    const cacheKeys = this._parseJSONOrNull(cacheKeysString);\n    if (!cacheKeys) {\n      return null;\n    }\n    const compileResult = this.parseCompileResult(compileResultString);\n    if (! compileResult) {\n      return null;\n    }\n\n    const cacheEntry = {compileResult, cacheKeys};\n    this._cache.set(cacheKey, cacheEntry);\n    return cacheEntry;\n  }\n\n  _writeCacheAsync(cacheKey, cacheEntry) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const cacheContents =\n      JSON.stringify(cacheEntry.cacheKeys) + '\\n' +\n      this.stringifyCompileResult(cacheEntry.compileResult);\n    this._writeFileAsync(cacheFilename, cacheContents);\n  }\n}\n"]}